---
sidebar_position: 6
---

# Колізії провайдерів

Уявіть, що у вас є `Module1`, куди ви імпортували `Module2` та `Module3`. Ви зробили такий імпорт, бо вам потрібні відповідно `Service2` та `Service3` із цих модулів. Ви проглядаєте результат роботи даних сервісів, але по якійсь причині `Service3` працює не так як очікується. Ви починаєте дебажити і виявляється, що `Service3` експортують обидва модулі: `Module2` та `Module3`. Ви очікували, що `Service3` експортуватиметься лише із `Module3`, але насправді спрацювала та версія, що експортується із `Module2`.

Щоб цього не сталось, якщо ви імпортуєте два або більше модулі, в яких експортуються неідентичні провайдери з однаковим токеном, Ditsmod кидатиме приблизно таку помилку:

> Error: Importing providers to Module1 failed: exports from Module2 and Module3 causes collision with Service3. If Module1 is intrernal module, you should add this provider to resolvedCollisionsPer* in Module1. For example: resolvedCollisionsPerReq: [ [Service3, Module3] ].

Конкретно у цій ситуації:

1. і `Module2` підмінює, а потім експортує провайдер з токеном `Service3`;
2. і `Module3` підмінює, а потім експортує провайдер з токеном `Service3`;
3. провайдери з токеном `Service3` є неідентичними у `Module2` та `Module3`, тобто із модуля `Module2` може еспортуватись, наприклад, об'єкт `{ provide: Service3, useValue: {} }`, а із `Module3` може еспортуватись `Service3` у вигляді класу.

І оскільки обидва ці модулі імпортуються у `Module1`, якраз тому і виникає "колізія провайдерів", розробник може не знати яка із цих підмін буде працювати в `Module1`.

## Вирішення колізії у внутрішньому модулі

Якщо `Module1` оголошено у вашому застосунку, цей модуль вважається внутрішнім відносно вашого застосунку.

Враховуючи рівень, на якому оголошено провайдери, колізія вирішується шляхом додавання до `resolvedCollisionsPer*` масиву з двох елементів, де на першому місці йде токен провайдера, а на другому - модуль, з якого потрібно брати відповідний провайдер:

```ts
import { Module2 } from './module2';
import { Module3, Service3 } from './module3';

@Module({
  imports: [Module2, Module3],
  resolvedCollisionsPerReq: [ [Service3, Module3] ]
})
export class Module1 {}
```

## Вирішення колізії у зовнішньому модулі

Якщо `Module1` ви встановили за допомогою менеджерів пакетів (npm, yarn і т.д.), цей модуль вважається зовнішнім відносно вашого застосунку. Немає сенсу локально змінювати зовнішній модуль щоб вирішити колізію.

Така ситуація може виникнути лише якщо `Module2` та `Module3` експортуються із кореневого модуля, тому вам потрібно видалити один із цих модулів звідти. Ну і, звичайно ж, після цього вам прийдеться імпортувати інший модуль, де він необхідний.