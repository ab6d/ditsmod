# HTTP Інтерсептори

Інтерсептори дуже близькі по функціональності до контролерів, але вони не створюють роутів, вони
прив'язуються до вже існуючих роутів. На одному роуті може працювати ціла група інтерсепторів, що
запускаються один за одним.

Враховуючи що інтерсептори роблять таку ж роботу, яку можуть робити контролери, без інтерсепторів
можна обійтись. Але в такому разі, як мінімум, вам прийдеться частіше викликати різні сервіси в
контролерах.

Як правило, інтерсептори використовуються для автоматизації стандартної обробки, такої як:

- парсинг тіла запиту, куків, заголовків;
- валідація запиту;
- перевірка прав доступів;
- збирання та логування різних метрик роботи застосунку.

Інтерсептори можна централізовано підключати чи відключати на рівні застосунку, модуля, роута чи
контролера, не змінюючи при цьому код методів контролерів, до яких вони прив'язуються.

Коли роутер передає HTTP-запит до обробника роута, де є інтерсептори, спочатку автоматично
запускається перший у черзі інтерсептор. А вже другий і наступні інтерсептори можуть і не
запуститись, це залежать від того, чи запустить їх попередній у черзі інтерсептор.

Якщо відпрацювали усі інтерсептори для певного роута, тільки тоді запускається відповідний метод
контролера.

## Створення інтерсептора

Кожен інтерсептор повинен бути класом, що впроваджує інтерфейс [HttpInterceptor][1], і цей клас
повинен мати анотацію з декоратором `Injectable`:

```ts
import { Injectable } from '@ts-stack/di';
import { HttpHandler, HttpInterceptor } from '@ditsmod/core';

@Injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  intercept(next: HttpHandler) {
    return next.handle(); // Here returns Promise<any>;
  }
}
```

Як бачите, метод `intercept()` отримує єдиний аргумент - це інстанс обробника, що викликає
наступний інтерсептор. Якщо для своєї роботи інтерсептор потребує певних даних, їх можна отримати
в конструкторі через DI, як і в будь-якому сервісі.

Зверніть увагу, що кожен виклик наступного інтерсептора повертає `Promise<any>`, і в кінцевому
підсумку він приводить до метода контролера, прив'язаного до відповідного роута. Це означає, що в
інтерсепторі ви можете прослуховувати результат резолву проміса, що повертає метод контролера.
Щоправда, на даний момент (v1.0.0), Ditsmod ігнорує усе що повертає контролер чи інтерсептори,
тому такий резолв проміса може бути корисним для інших цілей - для збору метрик, логування і т.п.

## Оголошення рівня інтерсептора

Будь-який інтерсептор оголошується на рівні запиту за допомогою мульти-провайдерів із токеном
`HTTP_INTERCEPTORS`:

```ts
import { HTTP_INTERCEPTORS, Module } from '@ditsmod/core';

import { MyHttpInterceptor } from './my-http-interceptor';

@Module({
  // ...
  providersPerReq: [{ provide: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true }],
})
export class SomeModule {}
```


[1]: ../api/http-interceptor
