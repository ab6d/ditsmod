---
sidebar_position: 0
---

# Модулі

## Модуль Ditsmod

Оскільки Ditsmod спроектовано для хорошої модульності, одним із головних елементів архітектури застосунку Ditsmod є його модулі. Але чим хороша саме модульна архітектура? - Вона дозволяє ізолювати в одному модулі **декілька файлів коду**, що можуть мати різні ролі, але **спільну спеціалізацію**. Модуль можна порівняти із оркестром, в якому є різні інструменти, але усі вони створюють спільну музику. З іншого боку, потреба в ізоляції різних модулів виникає через те, що вони можуть мати різну спеціалізацію і через це - можуть заважати один-одному. Продовжуючи аналогію із людьми, якщо в одому кабінеті розмістити поліцію та музикантів, або брокерів і перекладачів, швидше за все, вони заважатимуть один-одному. Саме тому для модуля важлива **вузька спеціалізація**.

Разом із тим, модулі можуть мати ще й різні типи, найчастіше це:

- **service** - у цей тип можна віднести модулі, що надають певні сервіси: модуль баз даних, модуль безпеки, модуль для запису логів, модуль для перекладу повідомлень різними мовами, і т.п.; такі модулі рідко закріпляються за певними URL.
- **routed** - у цей тип потрібно відносити модулі, що обслуговують певну частину URL: наприклад, один модуль може обробляти усі HTTP-запити за адресою `/api/users`, інший модуль - за адресою `/api/posts`.

Модулі можуть містити:
- контролери, що приймають HTTP-запити та відправляють HTTP-відповіді;
- сервіси, де описується бізнес логіка застосунку;
- інші класи, інтерфейси, хелпери, типи даних, що призначаються для роботи поточного модуля.

TypeScript клас стає модулем Ditsmod завдяки декоратору `Module`:

```ts
import { Module } from '@ditsmod/core';

@Module()
export class SomeModule {}
```

Файли модулів рекомендується називати із закінченням `*.module.ts`, а назви їхніх класів - із закінченням `*Module`.

У Ditsmod використовується декілька декораторів. Але чому саме декоратори? Тому що вони дозволяють сканувати класи. Завдяки декораторам, можна програмно розпізнавати:
- яку умовну роль закріплено за певним класом (роль модуля, контролера, сервіса і т.п.);
- чи має клас конструктор та які параметри він має;
- чи є у класа методи і які параметри вони мають;
- чи є інші властивості класу;
- інші метадані передані у декоратор.

:::tip Умовні ролі класу
Згадані тут ролі класу  - модуль, контролер, сервіс - є умовними (чи декларативними), оскільки вони мають значення виключно в контексті Ditsmod-застосунків, а сам TypeScript не має таких понять як "роль класу".
:::

Декоратори дозволяють декларативно описувати структуру застосунку, а тому можна легко проглядати що належить модулю, а також зв'язки одних модулів з іншими.

Загалом, в декоратор `Module` можна передавати об'єкт із такими властивостями:

```ts
import { Module } from '@ditsmod/core';

@Module({
  imports: [], // Імпорт модулів
  controllers: [], // Прив'язка контролерів до модуля
  providersPerApp: [], // Провайдери на рівні застосунку
  providersPerMod: [], //         ...на рівні модуля
  providersPerRou: [], //         ...на рівні роуту
  providersPerReq: [], //         ...на рівні запиту
  exports: [], // Експорт модулів та провайдерів із поточного модуля
  extensions: [], // Розширення
  extensionsMeta: {}, // Дані для роботи розширень
  resolvedCollisionsPerMod: [], // Вирішення колізій імпортованих класів на рівні модуля
  resolvedCollisionsPerRou: [], //                                    ...на рівні роута
  resolvedCollisionsPerReq: [], //                                    ...на рівні запиту
  id: '', // Може використовуватись для динамічного додавання чи видалення модулів
})
export class SomeModule {}
```

## Кореневий модуль Ditsmod

До кореневого модуля підв'язуються інші модулі, він є єдиним на увесь застосунок, а його клас рекомендовано називати `AppModule`. TypeScript клас стає кореневим модулем Ditsmod завдяки декоратору `RootModule`:

```ts
import { RootModule } from '@ditsmod/core';

@RootModule()
export class AppModule {}
```

Він може містити метадані як для HTTP-сервера так і для самого модуля. Загалом, в декоратор `RootModule` можна передавати об'єкт із такими властивостями:

```ts
import * as http from 'http';
import { RootModule } from '@ditsmod/core';

@RootModule({
  // Метадані для HTTP-сервера
  httpModule: http,
  listenOptions: { host: 'localhost', port: 3000 },
  serverName: 'Node.js',
  serverOptions: {},

  // Метадані для модуля, плюс - path - префікс, що додаватиметься до усіх маршрутів
  path: 'api',
  imports: [],
  controllers: [],
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [],
  exports: [],
  extensions: [],
  extensionsMeta: {},
  resolvedCollisionsPerApp: [],
  resolvedCollisionsPerMod: [],
  resolvedCollisionsPerRou: [],
  resolvedCollisionsPerReq: [],
})
export class AppModule {}
```
