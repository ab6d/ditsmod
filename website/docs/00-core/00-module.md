---
sidebar_position: 0
---

# Модулі

## Модуль Ditsmod

Якщо говорити дуже узагальнено, модуль повинен об'єднувати у собі набір класів, що мають вузьку спеціалізацію. Добре оформлений модуль не повинен бути "універсальним комбайном".

Наприклад, модуль системи безпеки має вузьку спеціалізацію - безпека доступу та безпека управління застосунком. Тут не повинні оголошуватись класи, наприклад, що перекладають повідомлення різними мовами, що відправляють пошту, що пишуть логи і т.п.

Коли конкретний модуль прив'язують до певного URL - це теж хороша практика, і це теж можна вважати "вузькою спеціалізацією". Наприклад, один модуль може обробляти усі HTTP-запити за адресою `/api/users`, інший модуль - за адресою `/api/posts`.

TypeScript клас стає модулем Ditsmod завдяки декоратору `Module`:

```ts
import { Module } from '@ditsmod/core';

@Module()
export class SomeModule {}
```

Файли модулів рекомендується називати із закінченням `*.module.ts`, а назви їхніх класів - із закінченням `*Module`.

У Ditsmod використовується декілька декораторів. Але чому саме декоратори? Тому що вони дозволяють сканувати класи. Завдяки декораторам, можна програмно розпізнавати:
- яку умовну роль закріплено за певним класом (роль модуля, контролера, сервіса і т.п.);
- чи має клас конструктор та які параметри він має;
- чи є у класа методи і які параметри вони мають;
- чи є інші властивості класу;
- інші метадані передані у декоратор.

Декоратори дозволяють декларативно описувати структуру застосунку, а тому можна легко проглядати зв'язки одних модулей з іншими.

Загалом, в декоратор `Module` можна передавати об'єкт із такими властивостями:

```ts
import { Module } from '@ditsmod/core';

@Module({
  imports: [], // Імпорт модулів
  controllers: [], // Прив'язка контролерів до модуля
  providersPerApp: [], // Провайдери на рівні застосунку
  providersPerMod: [], //         ...на рівні модуля
  providersPerRou: [], //         ...на рівні роуту
  providersPerReq: [], //         ...на рівні запиту
  exports: [], // Експорт модулів та провайдерів із поточного модуля
  extensions: [], // Розширення
  extensionsMeta: {}, // Дані для роботи розширень
  resolvedCollisionsPerMod: [], // Вирішення колізій імпортованих класів на рівні модуля
  resolvedCollisionsPerRou: [], //                                    ...на рівні роута
  resolvedCollisionsPerReq: [], //                                    ...на рівні запиту
  id: '', // Може використовуватись для динамічного додавання чи видалення модулів
})
export class SomeModule {}
```

## Кореневий модуль Ditsmod

До кореневого модуля підв'язуються інші модулі, він є єдиним на увесь застосунок, а його клас рекомендовано називати `AppModule`. TypeScript клас стає кореневим модулем Ditsmod завдяки декоратору `RootModule`:

```ts
import { RootModule } from '@ditsmod/core';

@RootModule()
export class AppModule {}
```

Він може містити метадані як для HTTP-сервера так і для самого модуля. Загалом, в декоратор `RootModule` можна передавати об'єкт із такими властивостями:

```ts
import * as http from 'http';
import { RootModule } from '@ditsmod/core';

@RootModule({
  // Метадані для HTTP-сервера
  httpModule: http,
  listenOptions: { host: 'localhost', port: 3000 },
  serverName: 'Node.js',
  serverOptions: {},

  // Метадані для модуля, плюс - префікс, що додаватиметься до усіх маршрутів
  prefixPerApp: 'api',
  imports: [],
  controllers: [],
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [],
  exports: [],
  extensions: [],
  extensionsMeta: {},
  resolvedCollisionsPerApp: [],
  resolvedCollisionsPerMod: [],
  resolvedCollisionsPerRou: [],
  resolvedCollisionsPerReq: [],
})
export class AppModule {}
```
