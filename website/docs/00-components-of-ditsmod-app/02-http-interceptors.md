---
sidebar_position: 2
---

# HTTP Інтерсептори

Інтерсептори дуже близькі по функціональності до контролерів, але вони не створюють роутів, вони прив'язуються до вже існуючих роутів. На одному роуті може працювати ціла група інтерсепторів, що запускаються один за одним.

Враховуючи що інтерсептори роблять таку ж роботу, яку можуть робити контролери, без інтерсепторів можна обійтись. Але в такому разі, як мінімум, вам прийдеться частіше викликати різні сервіси в контролерах.

Як правило, інтерсептори використовуються для автоматизації стандартної обробки, такої як:

- парсинг тіла запиту, куків, заголовків;
- валідація запиту;
- збирання та логування різних метрик роботи застосунку.

Інтерсептори можна централізовано підключати або відключати, не змінюючи при цьому код методів контролерів, до яких вони прив'язуються.

Коли починається обробка HTTP-запиту, спочатку Ditsmod витягує [HttpFrontend][2] через DI, ставить його першим у черзі інтерсепторів і автоматично викликає. By default, цей інтерсептор відповідає за виклик ґардів, встановлення `req.pathParams` та `req.queryParams`, а також за обробку помилок, що виникають під час роботи інтерсепторів та контролера.

Другий та наступні інтерсептори можуть і не запуститись, це залежать від того, чи запустить їх попередній у черзі інтерсептор.

Якщо усі інтерсептори відпрацювали, Ditsmod запускає [HttpBackend][3], що також витягується через DI. By default, `HttpBackend` запускає безпосередньо метод контролера, що відповідає за обробку поточного запиту.

Отже, порядок обробки запиту такий:

```text
HttpFrontend -> [інші інтерсептори] -> HttpBackend -> [контролер]
```

## Створення інтерсептора

Кожен інтерсептор повинен бути класом, що впроваджує інтерфейс [HttpInterceptor][1], та має анотацію з декоратором `Injectable`:

```ts
import { Injectable } from '@ts-stack/di';
import { HttpHandler, HttpInterceptor } from '@ditsmod/core';

@Injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  intercept(next: HttpHandler) {
    return next.handle(); // Here returns Promise<any>;
  }
}
```

Як бачите, метод `intercept()` отримує єдиний аргумент - це інстанс обробника, що викликає наступний інтерсептор. Якщо для своєї роботи інтерсептор потребує певних даних, їх можна отримати в конструкторі через DI, як і в будь-якому сервісі.

Зверніть увагу, що кожен виклик інтерсептора повертає `Promise<any>`, і в кінцевому підсумку він приводить до метода контролера, прив'язаного до відповідного роута. Це означає, що в інтерсепторі ви можете слухати результат резолву проміса, що повертає метод контролера.

Щоправда, на даний момент (Ditsmod v2.0.0), `HttpFrontend` та `HttpBackend` by default ігнорують усе, що повертає контролер чи інтерсептори, тому такий резолв проміса може бути корисним для інших цілей - для збору метрик, логування і т.п.

З іншого боку, через DI ви легко можете підмінити `HttpFrontend` та `HttpBackend` своїми власними інтерсепторами, щоб брати до уваги значення, що повертає метод контролера. Один із варіантів такої функціональності реалізовано у модулі [@ditsmod/return][4]. By default це не зроблено тому, що інколи роботу контролера потрібно продовжити після відправки HTTP-відповіді.

## Оголошення інтерсептора

Будь-який інтерсептор оголошується на рівні запиту за допомогою мульти-провайдерів із токеном `HTTP_INTERCEPTORS`:

```ts
import { HTTP_INTERCEPTORS, Module } from '@ditsmod/core';

import { MyHttpInterceptor } from './my-http-interceptor';

@Module({
  // ...
  providersPerReq: [{ provide: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true }],
})
export class SomeModule {}
```

[1]: https://github.com/ditsmod/ditsmod/blob/core-1.0.0/packages/core/src/types/http-interceptor.ts#L9-L11
[2]: https://github.com/ditsmod/ditsmod/blob/core-1.0.0/packages/core/src/types/http-interceptor.ts#L18-L20
[3]: https://github.com/ditsmod/ditsmod/blob/core-1.0.0/packages/core/src/types/http-interceptor.ts#L41-L43
[4]: ../02-published-modules/04-return.md