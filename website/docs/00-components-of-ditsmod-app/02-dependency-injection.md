---
sidebar_position: 2
---

# Dependency Injection

## Базові поняття

Ditsmod використовує [@ts-stack/di][9] у якості бібліотеки для Dependency Injection (скорочено - DI), вона має наступні базові поняття:

- залежність
- токен
- провайдер
- інжектор
- ієрархія інжекторів
- підміна провайдерів

## Залежність

В системі DI залежність - це усе те, що ви прописуєте у конструкторах контролерів, сервісів, модулів. Наприклад, якщо в конструкторі сервісу ви прописуєте ось таке:

```ts
import { Injectable } from '@ts-stack/di';

import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}
  // ...
}
```

це означає, що `SecondService` має залежність від `FirstService`, і очікується що DI вирішить цю залежність наступним чином: перед створенням інстансу `SecondService`, спочатку буде створено інстанс `FirstService`.

## Токен

Токен - це ідентифікатор для певної залежності. Тобто "залежність" - це те, що потрібно отримати в кінцевому результаті в конструкторі, а "токен" - це ідентифікатор, за допомогою якого ця залежність буде шукатись в DI. У попередньому прикладі у конструкторі - `FirstService` - це токен залежності.

DI дозволяє для одного і того ж токена передавати будь-яке значення в конструктор. Цю особливість зручно використовувати для тестування, оскільки замість справжньої залежності, для конструктора можна передати mock чи stub.

## Провайдер

DI вирішує залежність за допомогою відповідних провайдерів. На одну залежність, в DI потрібно передавати один або декілька провайдерів. У `@ts-stack/di` провайдер може бути або класом, або об'єктом з такими  властивостями:

```txt
{ provide: <token>, useClass: <class> },
{ provide: <token>, useValue: <any value> },
{ provide: <token>, useFactory: <function>, deps: [<array of providers>] },
{ provide: <token>, useExisting: <another token> },
```

У кожного провайдера є токен, але не кожен токен може бути провайдером. Фактично лише клас може виступати і у якості провайдера, і у якості токена. А, наприклад, текстове значення може бути лише токеном, але не провайдером.

Приклади використання цих об'єктів показані у розділі [Підміна провайдерів][102].

## Інжектор

Якщо сильно спростити схему роботи DI, можна сказати що DI приймає масив провайдерів на вході, а на виході видає інжектор, який вміє створювати інстанси переданих провайдерів враховуючи залежності між ними.

Якщо абстрагуватись від Ditsmod, на практиці це має приблизно наступну картину:

```ts
import 'reflect-metadata';
import { ReflectiveInjector, Injectable } from '@ts-stack/di';

class Service1 {}

@Injectable()
class Service2 {
  constructor(service1: Service1) {}
}

@Injectable()
class Service3 {
  constructor(service2: Service2) {}
}

const injector = ReflectiveInjector.resolveAndCreate([Service1, Service2, Service3]);
const service3 = injector.get(Service3);
```

Метод `ReflectiveInjector.resolveAndCreate()` на вході приймає масив класів, а на виході видає певний об'єкт, що називається інжектором. Цей інжектор очевидно містить у собі передані класи, і вміє створювати їхні інстанси, враховуючи весь ланцюжок залежностей (`Service3` -> `Service2` -> `Service1`).

Що робить інжектор:

- коли у нього запитують `Service3`, він проглядає конструктор цього класу, бачить залежність від `Service2`;
- потім проглядає конструктор у `Service2`, бачить залежність від `Service1`;
- потім проглядає конструктор у `Service1`, не знаходить там залежності, і тому першим створює інстанс `Service1`;
- потім створює інстанс `Service2`
- і останнім створює інстанс `Service3`.

В такому разі вам можна і не знати весь ланцюжок залежностей `Service3`, довірте цю роботу інжектору, головне - передайте йому в масив усі необхідні класи.

## Ієрархія інжекторів

Бібліотека `@ts-stack/di` дозволяє створювати ще й ієрархію інжекторів - це коли є батьківські та дочірні інжектори. На перший погляд, немає нічого цікавого у такій ієрархії, бо не зрозуміло для чого вона потрібна, але у Ditsmod ця можливість використовується якраз дуже часто, оскільки вона дозволяє робити архітектуру застосунку модульною. Вивченню специфіки ієрархії варто приділити особливу увагу, це в майбутньому збереже вам не одну годину часу, бо ви знатимете як воно працює і чому воно не знаходить цієї залежності...

При створенні ієрархії, зв'язок утримує лише дочірній інжектор, він має об'єкт батьківського інжектора. В той же час, батьківський інжектор нічого не знає про свої дочірні інжектори. Тобто зв'язок між інжекторами є одностороннім. Умовно, це виглядає наступним чином:

```ts
interface Parent {
  // Тут є певні властивості батьківського інжектора, але немає дочірнього інжектора
}

interface Child {
  parent: Parent;
  // Тут існують інші властивості дочірного інжектора.
}
```

Завдяки наявності об'єкта батьківського інжектора, дочірній інжектор може звертатись до батьківського інжектора, коли у нього запитують інстанс класу, якого у нього немає.

Давайте розглянемо наступний приклад. Для спрощення, тут взагалі не використовуються декоратори, оскільки кожен клас є незалежним:

```ts
import { ReflectiveInjector } from '@ts-stack/di';

class Service1 {}
class Service2 {}
class Service3 {}
class Service4 {}

const parent = ReflectiveInjector.resolveAndCreate([Service1, Service2]); // Батьківський інжектор
const child = parent.resolveAndCreateChild([Service2, Service3]); // Дочірній інжектор

child.get(Service1); // ОК
parent.get(Service1); // ОК

parent.get(Service1) === child.get(Service1); // true

child.get(Service2); // ОК
parent.get(Service2); // ОК

parent.get(Service2) === child.get(Service2); // false

child.get(Service3); // ОК
parent.get(Service3); // Error - No provider for Service3!

child.get(Service4); // Error - No provider for Service4!
parent.get(Service4); // Error - No provider for Service4!
```

Як бачите, при створенні дочірнього інжектора, йому не передали `Service1`, тому при запиті інстансу цього класу він звернеться до батька. До речі, тут є один неочевидний, але дуже важливий момент: дочірні інжектори хоча і запитують у батьківських інжекторів певні інстанси класів, але самостійно вони їх не створюють. Саме тому цей вираз повертає `true`:

```ts
parent.get(Service1) === child.get(Service1); // true
```

А `Service2` є в обох інжекторах, тому кожен із них створить свою локальну версію цього сервіса, і саме через це даний вираз повертає `false`:

```ts
parent.get(Service2) === child.get(Service2); // false
```

Батьківський інжектор не може створити інстансу класу `Service3` через те, що батьківський інжектор не має зв'язку із дочірнім інжектором, в якому є `Service3`.

Ну і обидва інжектори не можуть видати інстансу `Service4`, бо їм не передали цього класу при їхньому створенні.

### Ієрархія інжекторів контролера

Будь-який контролер, окрім свого власного інжектора на рівні запиту, має ще й три батьківські інжектори: на рівні роута, модуля та застосунка. Ці інжектори формуються на основі тих даних, які ви передаєте в наступні масиви:

- `providersPerApp`;
- `providersPerMod`;
- `providersPerRou`;
- `providersPerReq` (<-- це масив, з якого формується інжектор для контролера).

Ці імена властивостей ви можете зустріти або у метаданих контролера, або у метаданих модуля.

### Ієрархія інжекторів сервіса

На відміну від контролера, інжектор певного сервіса може бути на будь-якому рівні: на рівні застосунку, модуля, роуту, чи запиту. На практиці це означає, що провайдер для даного сервіса передається в один (або в декілька) із вищезазначених масивів. Наприклад, в наступному прикладі `SomeService` передається інжектору на рівні запиту, а `OtherService` - на рівні модуля:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';
import { OtherService } from './other.service';

@Module({
  providersPerMod: [OtherService],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

В даному разі, якщо `SomeService` матиме залежність від `OtherService`, DI зможе створити інстанс `SomeService`, оскільки інжектор на рівні запиту може отримати інстанс `OtherService` від свого батьківського інжектора на рівні модуля. А от якщо навпаки - `OtherService` матиме залежність від `SomeService` - DI не зможе створити інстансу `OtherService`, оскільки інжектор на рівні модуля не бачить свого дочірнього інжектора на рівні запиту.

### Поточний інжектор

Безпосередньо сам інжектор вам рідко може знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { Injectable, Injector } from '@ts-stack/di';
import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного сервіса.

## Основні етапи роботи DI у застосунках Ditsmod

Можна виділити 4 основні етапи:

1. Сканування метаданих, зібраних з декораторів модулів, контролерів та сервісів.
2. На основі просканованих метаданих, формування ієрархії інжекторів з урахуванням декларацій імпортів/експортів кожного модуля.
3. Запит певної залежності.
4. Вирішення цієї залежності з використанням раніше сформованих інжекторів.

Перші 2 етапи відбуваються під час ініціалізації застосунку, перед стартом веб-сервера, а решта - під час обробки HTTP-запиту.

## Повторне додавання провайдерів

У певному модулі, один і той самий провайдер, на одному й тому самому рівні можна додавати багато разів, але DI вибере той із них, що додано останнім (виключення з цього правила є, але це стосується лише [мульти-провайдерів][10]). Окрім цього, один і той самий провайдер можна передавати одночасно на чотирьох рівнях, але DI завжди буде вибирати найближчі інжектори (тобто, якщо значення для провайдера запитується на рівні запиту, то спочатку буде проглядатись інжектор на рівні запиту, і лише якщо там немає потрібного провайдера, DI буде підніматись до батьківських інжекторів).

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**
2. при потребі змінити дану конфігурацію лише для окремого модуля, зробіть підміну цього провайдера, але вже **на рівні модуля**.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони передавались на однаковому рівні.

## Підміна провайдерів Ditsmod

Оскільки усі default провайдери додаються до DI першими, кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підмінити `Logger` своїм провайдером, ваш провайдер повинен мати такі ж імена методів, і таку ж сигнатуру цих методів як вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну за допомогою DI:

```ts
import { RootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@RootModule({
  providersPerApp: [{ provide: Logger, useClass: MyLogger }],
})
export class SomeModule {}
```

Щоб підмінити будь-який default провайдер Ditsmod вашим власним провайдером, алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте API провайдерів, які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну default провайдера вашим провайдером.

## Коли DI не може знайти потрібного провайдера

Пам'ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:

1. ви не додали потрібний провайдер в метадані модуля чи контролера;
2. ви не імпортували модуль, де передається потрібний вам провайдер, або ж цей провайдер не експортується;
3. ви запитуєте у батьківському інжекторі провайдер із дочірнього інжектора.


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://ts-stack.github.io/di/
[10]: https://ts-stack.github.io/di/#%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D0%B8

[107]: ./exports-and-imports
[121]: ./providers-collisions
[100]: #підміна-провайдерів-ditsmod
[101]: #ієрархія-інжекторів
[102]: #підміна-провайдерів-ditsmod
