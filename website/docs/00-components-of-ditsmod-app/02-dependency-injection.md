---
sidebar_position: 2
---

# Dependency Injection

## Базові поняття

Ditsmod використовує [@ts-stack/di][9] у якості бібліотеки для Dependency Injection, вона має наступні базові поняття:

- провайдер
- токен
- інжектор
- ієрархія інжекторів
- підміна провайдерів

Якщо сильно спростити схему роботи Dependency Injection (скорочено - DI), можна сказати що DI приймає масив провайдерів на вході, а на виході видає інжектор, який вміє створювати інстанси переданих провайдерів враховуючи залежності між ними.

Якщо абстрагуватись від Ditsmod, на практиці це має приблизно наступну картину:

```ts
import 'reflect-metadata';
import { ReflectiveInjector, Injectable } from '@ts-stack/di';

class Service1 {}

@Injectable()
class Service2 {
  constructor(service1: Service1) {}
}

@Injectable()
class Service3 {
  constructor(service2: Service2) {}
}

const injector = ReflectiveInjector.resolveAndCreate([Service1, Service2, Service3]);
const service3 = injector.get(Service3);
```

Метод `ReflectiveInjector.resolveAndCreate()` на вході приймає масив класів, а на виході видає певний об'єкт, що називається інжектором. Цей інжектор очевидно містить у собі передані класи, і вміє створювати їхні інстанси, враховуючи весь ланцюжок залежностей (`Service3` -> `Service2` -> `Service1`).

Тобто робота інжектора якраз і полягає в тому, що коли у нього запитують `Service3`, він проглядає конструктор цього класу, бачить залежність від `Service2`, проглядає вже його конструктор, бачить залежність від `Service1`, проглядає його конструктор, не знаходить там залежності, і тому створює першим - інстанс `Service1`. Після того, як вже є інстанс `Service1`, можна створювати інстанс `Service2`, а коли і це вже зроблено, можна нарешті, у саму останню чергу створити інстанс `Service3`.

В такому разі вам можна і не знати весь ланцюжок залежностей `Service3`, довірте цю роботу інжектору, головне - передайте йому в масив усі необхідні класи.

## Ієрархія інжекторів

Бібліотека `@ts-stack/di` дозволяє створювати ще й ієрархію інжекторів - це коли є батьківські та дочірні інжектори. На перший погляд, немає нічого цікавого у такій ієрархії, бо не зрозуміло для чого вона потрібна, але у Ditsmod ця можливість використовується якраз дуже часто, оскільки вона дозволяє робити архітектуру застосунку модульною. Вивченню специфіки ієрархії варто приділити особливу увагу, це в майбутньому збереже вам не одну годину роботи, бо ви знатимете як воно працює і чому воно не знаходить цієї залежності...

При створенні ієрархії, зв'язок утримує лише дочірній інжектор, він має об'єкт батьківського інжектора. В той же час, батьківський інжектор нічого не знає про свої дочірні інжектори. Тобто зв'язок між інжекторами є одностороннім. Умовно, це виглядає наступним чином:

```ts
interface Parent {
  // Тут є певні властивості батьківського інжектора, але немає дочірнього інжектора
}

interface Child {
  parent: Parent;
  // Тут існують інші властивості дочірного інжектора.
}
```

Завдяки наявності об'єкта батьківського інжектора, дочірній інжектор може звертатись до батьківського інжектора, коли у нього запитують інстанс класу, якого у нього немає.

Давайте розглянемо наступний приклад. Для спрощення, тут взагалі не використовуються декоратори, оскільки кожен клас є незалежним:

```ts
import { ReflectiveInjector } from '@ts-stack/di';

class Service1 {}
class Service2 {}
class Service3 {}
class Service4 {}

const parent = ReflectiveInjector.resolveAndCreate([Service1, Service2]); // Батьківський інжектор
const child = parent.resolveAndCreateChild([Service2, Service3]); // Дочірній інжектор

child.get(Service1); // ОК
parent.get(Service1); // ОК

parent.get(Service1) === child.get(Service1); // true

child.get(Service2); // ОК
parent.get(Service2); // ОК

parent.get(Service2) === child.get(Service2); // false

child.get(Service3); // ОК
parent.get(Service3); // Error - No provider for Service3!

child.get(Service4); // Error - No provider for Service4!
parent.get(Service4); // Error - No provider for Service4!
```

Як бачите, при створенні дочірнього інжектора, йому не передали `Service1`, тому при запиті інстансу цього класу він звернеться до батька. До речі, тут є один неочевидний, але дуже важливий момент: дочірні інжектори хоча і запитують у батьківських інжекторів певні інстанси класів, але самостійно вони їх не створюють. Саме тому цей вираз повертає `true`:

```ts
parent.get(Service1) === child.get(Service1); // true
```

А `Service2` є в обох інжекторах, тому кожен із них створить свою локальну версію, і саме через це даний вираз повертає `false`:

```ts
parent.get(Service2) === child.get(Service2); // false
```

Батьківський інжектор не може створити інстансу класу `Service3` через те, що батьківський інжектор не має зв'язку із дочірнім інжектором, в якому є `Service3`.

Ну і обидва інжектори не можуть видати інстансу `Service4`, бо їм не передали цього класу при їхньому створенні.

### Ієрархія інжекторів контролера

Будь-який контролер, окрім свого власного інжектора на рівні запиту, має ще й три батьківські інжектори на рівні роута, модуля та застосунка. Ці інжектори формуються на основі тих даних, які ви передаєте в наступних масивах:

- `providersPerApp`;
- `providersPerMod`;
- `providersPerRou`;
- `providersPerReq` (<-- це масив, з якого формується інжектор для контролера).

Ці імена властивостей ви можете зустріти або у метаданих контролера, або у метаданих модуля.

### Ієрархія інжекторів провайдера

На відміну від контролера, провайдер певного сервісу може взагалі не мати батьківських інжекторів, хоча може мати їх стільки ж, скільки їх має контролер, усе залежить від **рівня** оголошення провайдера. На практиці це означає, що провайдер передається в один (або в декілька) із вищезазначених масивів. Наприклад, в наступному прикладі `SomeService` оголошується на рівні запиту, а `OtherService` - на рівні модуля:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';
import { OtherService } from './other.service';

@Module({
  providersPerMod: [OtherService],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

В даному разі, якщо `SomeService` матиме залежність від `OtherService`, DI зможе створити інстанс `SomeService`, оскільки інжектор на рівні запиту може отримати інстанс `OtherService` від свого батьківського інжектора на рівні модуля. А от якщо навпаки - `OtherService` матиме залежність від `SomeService` - DI не зможе створити інстансу `OtherService`, оскільки інжектор на рівні модуля не бачить свого дочірнього інжектора на рівні запиту.

### Поточний інжектор

Безпосередньо сам інжектор вам рідко може знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { Injectable, Injector } from '@ts-stack/di';
import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного провайдера.

## Базові етапи роботи DI у застосунках Ditsmod

Можна виділити 4 основні етапи:

1. Сканування метаданих, зібраних з декораторів модулів, контролерів та сервісів.
2. На основі просканованих метаданих, формування ієрархії інжекторів з урахуванням декларацій імпортів/експортів кожного модуля.
3. Запит інстансу певного провайдера.
4. Створення інстансу даного провайдера з використанням раніше сформованих інжекторів.

Перші 2 етапи відбуваються під час ініціалізації застосунку, перед стартом веб-сервера.

## Повторне додавання провайдерів

У певному модулі, один і той самий провайдер, на одному й тому самому рівні можна додавати багато разів, але DI вибере той із них, що додано останнім (виключення з цього правила є, але це стосується лише [мульти-провайдерів][10]). Окрім цього, один і той самий провайдер можна оголошувати одночасно на чотирьох рівнях, але DI завжди буде вибирати найближчі інжектори (тобто, якщо значення для провайдера запитується на рівні запиту, то спочатку буде проглядатись інжектор на рівні запиту, і лише якщо там немає потрібного провайдера, DI буде підніматись до батьківських інжекторів).

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**
2. при потребі змінити дану конфігурацію лише для окремого модуля, оголосіть цей же провайдер конфігурації, але вже **на рівні модуля**, і зробіть його підміну.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони оголошені на однаковому рівні.

## Підміна провайдерів Ditsmod

Оскільки усі default провайдери додаються до DI першими, кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підмінити `Logger` своїм провайдером, ваш провайдер повинен мати такі ж імена методів, і таку ж сигнатуру цих методів як вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну за допомогою DI:

```ts
import { RootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@RootModule({
  providersPerApp: [{ provide: Logger, useClass: MyLogger }],
})
export class SomeModule {}
```

Щоб підмінити будь-який default провайдер Ditsmod вашим власним провайдером, алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте API провайдерів, які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну default провайдера вашим провайдером.

## Області видимості та рівні оголошення

Не варто плутати чотири рівня оголошення провайдерів із областю їх видимості. Коли ви передаєте провайдер у один із масивів: `providersPerApp`, `providersPerMod`, `providersPerRou` чи `providersPerReq` - тим самим ви декларуєте на якому рівні буде створюватись [одинак][12] даного провайдера. Але це не теж саме, що область видимості провайдерів.

Наприклад, якщо у `SomeModule` ви оголосили `ConfigService` на рівні `providersPerMod`, це означає, що одинак даного сервісу буде створений на рівні даного модуля і стане доступним лише в межах цього модуля. Тобто будь-який інший модуль покищо не зможе побачити `ConfigService`.

Разом із тим, щоб збільшити область видимості `ConfigService` ви повинні експортувати його із `SomeModule`, після чого усі модулі, що імпортують `SomeModule`, теж матимуть свій окремий одинак `ConfigService` на рівні модуля.

Як бачите, область видимості провайдерів розширюється за допомогою [експорту цих провайдерів][107] з подальшим імпортом модулів, де вони оголошені. Якщо  в кореневому модулі зробити експорт потрібних провайдерів, їх область видимості збільшиться на увесь застосунок, з урахуванням ієрархії інжекторів (вони стають глобальними).

Але якщо область видимості не розширювати, вона буде обмежуватись лише [ієрархією інжекторів DI][101].

:::tip Коли DI не може знайти потрібного провайдера
Пам'ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:
1. ви не додали потрібний провайдер в метадані модуля чи контролера;
2. ви не імпортували модуль, де оголошено потрібний вам провайдер, або ж цей провайдер не експортується;
3. ви запитуєте у батьківському інжекторі провайдер із дочірнього інжектора.
:::


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://ts-stack.github.io/di/
[10]: https://ts-stack.github.io/di/#%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D0%B8

[107]: ./exports-and-imports
[121]: ./providers-collisions
[100]: #підміна-провайдерів-ditsmod
[101]: #ієрархія-інжекторів
