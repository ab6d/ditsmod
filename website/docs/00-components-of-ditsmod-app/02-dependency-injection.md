---
sidebar_position: 2
---

# Dependency Injection

## Базові поняття

Ditsmod використовує [@ts-stack/di][9] у якості бібліотеки для Dependency Injection, вона має наступні базові поняття:

- провайдер
- токен
- інжектор
- ієрархія інжекторів
- підміна провайдерів

Якщо сильно спростити схему роботи Dependency Injection (скорочено - DI), можна сказати що DI приймає масив провайдерів на вході, а на виході видає інжектор, який вміє створювати інстанси переданих провайдерів враховуючи залежності між ними.

Якщо абстрагуватись від Ditsmod, на практиці це має приблизно наступну картину:

```ts
import 'reflect-metadata';
import { ReflectiveInjector, Injectable } from '@ts-stack/di';

class Service1 {}

@Injectable()
class Service2 {
  constructor(service1: Service1) {}
}

@Injectable()
class Service3 {
  constructor(service2: Service2) {}
}

const injector = ReflectiveInjector.resolveAndCreate([Service1, Service2, Service3]);
const service3 = injector.get(Service3);
```

Метод `ReflectiveInjector.resolveAndCreate()` на вході приймає масив класів, а на виході видає певний об'єкт, що називається інжектором. Цей інжектор очевидно містить у собі передані класи, і вміє створювати їхні інстанси, враховуючи весь ланцюжок залежностей (`Service3` -> `Service2` -> `Service1`).

Тобто робота інжектора якраз і полягає в тому, що коли у нього запитують `Service3`, він проглядає конструктор цього класу, бачить залежність від `Service2`, проглядає вже його конструктор, бачить залежність від `Service1`, проглядає його конструктор, не знаходить там залежності, і тому створює першим - інстанс `Service1`. Після того, як вже є інстанс `Service1`, можна створювати інстанс `Service2`, а коли і це вже зроблено, можна нарешті, у саму останню чергу створити інстанс `Service3`.

В такому разі вам можна і не знати весь ланцюжок залежностей `Service3`, довірте цю роботу інжектору, головне - передайте йому в масив усі необхідні класи.

## Ієрархія інжекторів

Бібліотека `@ts-stack/di` дозволяє створювати ще й ієрархію інжекторів - це коли є батьківські та дочірні інжектори. На перший погляд, немає нічого цікавого у такій ієрархії, бо не зрозуміло для чого вона потрібна, але у Ditsmod ця можливість використовується якраз дуже часто, оскільки вона дозволяє робити архітектуру застосунку модульною. Вивченню специфіки ієрархії варто приділити особливу увагу, це в майбутньому збереже вам не одну годину роботи, бо ви знатимете як воно працює і чому воно не знаходить цієї залежності...

При створенні ієрархії, зв'язок утримує лише дочірній інжектор, він має об'єкт батьківського інжектора. В той же час, батьківський інжектор нічого не знає про свої дочірні інжектори. Тобто зв'язок між інжекторами є одностороннім. Умовно, це виглядає наступним чином:

```ts
interface Parent {
  // Тут є певні властивості батьківського інжектора, але немає дочірнього інжектора
}

interface Child {
  parent: Parent;
  // Тут існують інші властивості дочірного інжектора.
}
```

Завдяки наявності об'єкта батьківського інжектора, дочірній інжектор може звертатись до батьківського інжектора, коли у нього запитують інстанс класу, якого у нього немає.

Давайте розглянемо наступний приклад. Для спрощення, тут взагалі не використовуються декоратори, оскільки кожен клас є незалежним:

```ts
import { ReflectiveInjector } from '@ts-stack/di';

class Service1 {}
class Service2 {}
class Service3 {}
class Service4 {}

const parent = ReflectiveInjector.resolveAndCreate([Service1, Service2]); // Батьківський інжектор
const child = parent.resolveAndCreateChild([Service2, Service3]); // Дочірній інжектор

child.get(Service1); // ОК
parent.get(Service1); // ОК

parent.get(Service1) === child.get(Service1); // true

child.get(Service2); // ОК
parent.get(Service2); // ОК

parent.get(Service2) === child.get(Service2); // false

child.get(Service3); // ОК
parent.get(Service3); // Error - No provider for Service3!

child.get(Service4); // Error - No provider for Service4!
parent.get(Service4); // Error - No provider for Service4!
```

Як бачите, при створенні дочірнього інжектора, йому не передали `Service1`, тому при запиті інстансу цього класу він звернеться до батька. До речі, тут є один неочевидний, але дуже важливий момент: дочірні інжектори хоча і запитують у батьківських інжекторів певні інстанси класів, але самостійно вони їх не створюють. Саме тому цей вираз повертає `true`:

```ts
parent.get(Service1) === child.get(Service1); // true
```

А `Service2` є в обох інжекторах, тому кожен із них створить свою локальну версію, і саме через це даний вираз повертає `false`:

```ts
parent.get(Service2) === child.get(Service2); // false
```

Батьківський інжектор не може створити інстансу класу `Service3` через те, що батьківський інжектор не має зв'язку із дочірнім інжектором, в якому є `Service3`.

Ну і обидва інжектори не можуть видати інстансу `Service4`, бо їм не передали цього класу при їхньому створенні.

### Ієрархія інжекторів контролера

Будь-який контролер, окрім свого власного інжектора на рівні запиту, має ще й три батьківські інжектори на рівні роута, модуля та застосунка. Ці інжектори формуються на основі тих даних, які ви передаєте в наступних масивах:

- `providersPerApp`;
- `providersPerMod`;
- `providersPerRou`;
- `providersPerReq` (<-- це масив, з якого формується інжектор для контролера).

Ці імена властивостей ви можете зустріти або у метаданих контролера, або у метаданих модуля.

### Ієрархія інжекторів провайдера

На відміну від контролера, провайдер певного сервісу може взагалі не мати батьківських інжекторів, хоча може мати їх стільки ж, скільки їх має контролер, усе залежить від **рівня** оголошення провайдера. На практиці це означає, що провайдер передається в один (або в декілька) із вищезазначених масивів. Наприклад, в наступному прикладі `SomeService` оголошується на рівні запиту, а `OtherService` - на рівні модуля:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';
import { OtherService } from './other.service';

@Module({
  providersPerMod: [OtherService],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

В даному разі, якщо `SomeService` матиме залежність від `OtherService`, DI зможе створити інстанс `SomeService`, оскільки інжектор на рівні запиту може отримати інстанс `OtherService` від свого батьківського інжектора на рівні модуля. А от якщо навпаки - `OtherService` матиме залежність від `SomeService` - DI не зможе створити інстансу `OtherService`, оскільки інжектор на рівні модуля не бачить свого дочірнього інжектора на рівні запиту.

## Базові етапи роботи DI у застосунках Ditsmod

Можна виділити 4 основні етапи:

1. Сканування метаданих, зібраних з декораторів модулів, контролерів та сервісів.
2. На основі просканованих метаданих, формування ієрархії інжекторів з урахуванням декларацій імпортів/експортів кожного модуля.
3. Запит інстансу певного провайдера.
4. Створення інстансу даного провайдера з використанням раніше сформованих інжекторів.

Перші 2 етапи відбуваються під час ініціалізації застосунку, перед стартом веб-сервера.

## Повторне додавання провайдерів

У певному модулі, один і той самий провайдер, на одному й тому самому рівні можна додавати багато разів, але DI вибере той із них, що додано останнім (виключення з цього правила є, але це стосується лише [мульти-провайдерів][10]). Окрім цього, один і той самий провайдер можна оголошувати одночасно на чотирьох рівнях, але провайдери в масиві `providersPerReq` матимуть найвищий пріоритет, в масиві `providersPerRou` - нижчій, в масиві `providersPerMod` - ще нижчій, а у `providersPerApp` - найнижчий пріоритет.

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**
2. при потребі змінити дану конфігурацію лише для окремого модуля, оголосіть цей же провайдер конфігурації, але вже **на рівні модуля**, і зробіть його підміну.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони оголошені на однаковому рівні.

## Підміна провайдерів Ditsmod

Оскільки усі default провайдери додаються до DI першими, кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підмінити `Logger` своїм провайдером, ваш провайдер повинен мати такі ж імена методів, і таку ж сигнатуру цих методів як вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну за допомогою DI:

```ts
import { RootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@RootModule({
  providersPerApp: [{ provide: Logger, useClass: MyLogger }],
})
export class SomeModule {}
```

Щоб підмінити будь-який default провайдер Ditsmod вашим власним провайдером, алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте API провайдерів, які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну default провайдера вашим провайдером.

## Області видимості та рівні оголошення

Не варто плутати чотири рівня оголошення провайдерів із областю їх видимості. Коли ви передаєте провайдер у один із масивів: `providersPerApp`, `providersPerMod`, `providersPerRou` чи `providersPerReq` - тим самим ви декларуєте на якому рівні буде створюватись [одинак][12] даного провайдера. Але це не теж саме, що область видимості провайдерів.

Наприклад, якщо у `SomeModule` ви оголосили `ConfigService` на рівні `providersPerMod`, це означає, що одинак даного сервісу буде створений на рівні даного модуля і стане доступним лише в межах цього модуля. Тобто будь-який інший модуль покищо не зможе побачити `ConfigService`.

Разом із тим, щоб збільшити область видимості `ConfigService` ви повинні експортувати його із `SomeModule`, після чого усі модулі, що імпортують `SomeModule`, теж матимуть свій окремий одинак `ConfigService` на рівні модуля.

Як бачите, область видимості провайдерів розширюється за допомогою [експорту цих провайдерів][107] з подальшим імпортом модулів, де вони оголошені. Хоча, якщо провайдери оголошені у кореневому модулі, і вони потрібні вам в іншому модулі, імпортувати кореневий модуль не потрібно. Достатньо в кореневому модулі зробити експорт потрібних провайдерів, після чого їх область видимості збільшиться на увесь застосунок, з урахуванням ієрархії інжекторів.

Але якщо область видимості не розширювати, вона буде обмежуватись лише ієрархією інжекторів DI.

:::tip Коли DI не може знайти потрібного провайдера
Пам'ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:
1. ви не додали потрібний провайдер в метадані модуля чи контролера;
2. ви не імпортували модуль, де є оголошено потрібний вам провайдер, або ж цей провайдер не експортується;
3. ви запитуєте у батьківському інжекторі провайдер із дочірнього інжектора.
:::

## Інжектори DI

Інжектори є складовою частиною DI, саме інжектори видають вам те, що ви запитуєте у конструкторах класів.

Інжектори - це інстанси класів, що мають масиви провайдерів та методи для створення інстансів цих провайдерів, з урахуванням всього ланцюжка їх залежностей. Коли ви передаєте провайдери в масиви `providersPerApp`, `providersPerMod`, `providersPerRou` та `providersPerReq` ви фактично передаєте ці дані в чотири різні інжектори, пов'язані між собою ієрархічним зв'язком. Цей зв'язок утримує дочірній інжектор, оскільки має посилання на батьківський інжектор. У той же час, батьківський інжектор нічого не знає про свої дочірні інжектори.

_Уточнення:_ згадані чотири інжектори - це не загальна кількість інжекторів в застосунку, це кількість інжекторів в ієрархії. Тобто, окремо взятий контролер працює саме із цими чотирма інжекторами, але оскільки контролерів може бути багато, то й інжекторів відповідно може бути більше.

Отже, згадані чотири інжектори мають таку ієрархію:

1. Самий вищий в ієрархії - інжектор на рівні застосунку, він бачить лише ті провайдери, що ви передаєте у масив `providersPerApp` будь-де в застосунку. Він є єдиним на весь застосунок, від нього відгалуджуються дочірні інжектори на рівні модуля.
2. Інжектор на рівні модуля бачить усі провайдери в масиві `providersPerMod` для конкретного модуля, а також в масиві `providersPerApp` будь-де в застосунку. Загальна кількість таких інжекторів дорівнює кількості модулів у застосунку. Від цього інжектора відгалуджуються дочірні інжектори на рівні роуту.
3. Інжектор на рівні роуту бачить усі провайдери в масиві `providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Загальна кількість цих інжекторів дорівнює кількості визначених роутів в контролерах усього застосунку. Від цього інжектора відгалуджуються дочірні інжектори на рівні HTTP-запиту.
4. Інжектор на рівні HTTP-запиту бачить усі провайдери в масиві `providersPerReq`, `providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Загальна кількість цих інжекторів дорівнює кількості одночасних HTTP-запитів, що обробляються у заданий проміжок часу.

Кожен інжектор для створення [одинаків][12] сервісів використовує лише ті провайдери, що оголошені на його рівні. Наприклад, інжектор, на рівні запиту, створює одинаків лише з переліку провайдерів, оголошених в масиві `providersPerReq`. І хоча цей інжектор інколи запитує інстанси провайдерів у батьківських інжекторів, але самостійно він їх не створює. Таким чином, в конструкторі контролера можуть бути одинаки з будь-якого рівня.

Кожен інжектор спочатку проглядає те, що у нього запитують, на своєму рівні. Якщо він це не знаходить, він може звернутись до батьківського інжектора, що знаходиться на рівень вище, якщо такий існує. А батьківський інжектор, у свою чергу, може піднятись ще вище, аж поки не знайде потрібне, в противному разі DI кидає помилку.

Щоб зрозуміти, що це означає на практиці, давайте розглянемо конкретний приклад.

Припустимо ви створили `ErrorHandlerService` і думаєте: "Де б його оголосити? - Раз цей сервіс може знадобитись у будь-якій точці застосунку, значить треба оголосити його саме на рівні застосунку, тобто в масиві `providersPerApp`". Але при цьому, в даному сервісі ви хочете бачити інстанси класу `Req` та `Res`, які в Ditsmod оголошені на рівні запиту:

```ts
import { Injectable } from '@ts-stack/di';
import { Logger, Req, Res, ControllerErrorHandler } from '@ditsmod/core';

@Injectable()
export class ErrorHandlerService implements ControllerErrorHandler {
  constructor(
    private req: Req,
    private res: Res,
    private log: Logger
  ) {}

  handleError(err: Error) {
    // Тут код для обробки помилки
  }
}
```

Ви запускаєте застосунок, і коли справа доходить до роботи цього сервісу, DI кидає помилку, про те, що він не може знайти провайдера для `Req` та `Res`. Але чому? Може їх треба самостійно оголосити на рівні HTTP-запиту, тобто додати їх у масив `providersPerReq`? Ви так і робите, але DI все-одно кидає помилку...

Причина криїться у невірно оголошеному рівні для `ErrorHandlerService`. Оскільки ви оголосили цей сервіс на рівні застосунку, його інстанс буде створювати інжектор на рівні застосунку. А це означає, що усі сервіси, що ви запитуєте в конструкторі, цей інжектор буде шукати тільки в масиві, що ви передали у `providersPerApp`.

Разом з тим, `Req` та `Res` в Ditsmod оголошені на рівні запиту, тобто ці сервіси перебувають у дочірніх інжекторах, по відношенню до інжектора на рівні застосунку. А батьківський інжектор нічого не знає про дочірні інжектори.

Вирішити цю проблему можна двома способами:

1. видаліть `Req` та `Res` з конструктора даного сервіса;
2. оголосіть `ErrorHandlerService` на рівні запиту. Щоправда, в такому разі видимість `ErrorHandlerService` все ще буде обмежуватись тим модулем, де ви оголосили цей провайдер. Як правильно оголосити обробника помилок для контролера, прогляньте [репозиторій ditsmod seed][14].

### Поточний інжектор

Безпосередньо сам інжектор вам рідко може знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { Injectable, Injector } from '@ts-stack/di';
import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного провайдера.


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://ts-stack.github.io/di/
[10]: https://ts-stack.github.io/di/#%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D0%B8

[107]: ./exports-and-imports
[121]: ./providers-collisions
[100]: #підміна-провайдерів-ditsmod
