---
sidebar_position: 2
---

# Dependency Injection

## Базові поняття

Ditsmod DI має наступні базові поняття:

- залежність
- токен залежності, типи токенів
- провайдер
- інжектор
- ієрархія інжекторів
- підміна провайдерів

## Залежність

Якщо для створення інстанса даного класа вам потрібно спочатку створити інстанси інших класів - значить даний клас має залежності. Наприклад, якщо в конструкторі сервісу ви прописуєте ось таке:

```ts {7}
import { injectable } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}
  // ...
}
```

це означає, що `SecondService` має залежність від `FirstService`, і очікується що DI вирішить цю залежність наступним чином:

1. спочатку DI прогляне конструктор `FirstService`;
2. якщо у `FirstService` немає залежності, буде створено інстанс `FirstService`;
3. інстанс `FirstService` буде передано в конструктор `SecondService`.

Якщо після виконання першого пункту виясниться, що `FirstService` має свої власні залежності, то DI буде рекурсивно виконувати ці три пункти для кожної даної залежності.

### Опціональна залежність

Інколи вам може знадобитись вказати опціональну (необов'язкову) залежність в конструкторі. Давайте розглянемо наступний приклад, де після властивості `firstService` поставлено знак питання, і таким чином вказано для TypeScript що ця властивість є опціональною:

```ts {7}
import { injectable } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private firstService?: FirstService) {}
  // ...
}
```

Але DI проігнорує цю опціональність і видасть помилку у разі відсутності можливості для створення `FirstService`. Щоб даний код працював, необхідно скористатись декоратором `optional`:

```ts {7}
import { injectable, optional } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(@optional() private firstService?: FirstService) {}
  // ...
}
```

## Токен залежності

Вище сказано, що в конструкторах класів указуються залежності для того, щоб DI вирішував ці залежності. Треба уточнити, що залежності в конструкторах указуються за допомогою так званих **токенів**, з яких DI формує реєстр залежностей.

Давайте знову розглянемо попередній приклад:

```ts {7}
import { injectable } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}
  // ...
}
```

Тут `FirstService` - це токен, за допомогою якого вказується залежність `SecondService` від `FirstService`.

Токен може мати будь-який тип, але на даний момент у DI є обмеження, через яке DI не бачить різниці між різними примітивнами типами, різними типами _масивів_ чи _enum_. Окрім цього, ви повинні пам'ятати, що токен повинен залишитись у JavaScript-файлі після компіляції з TypeScript-коду, тому у якості токена не можна використовувати інтерфейси або типи, що оголошені за допомогою ключового слова `type`.

## Декоратор `inject`

Декоратор `inject` дозволяє використовувати альтернативний токен, він необхідний для отримання в конструкторі ризних примітивних типів, масивів, enum, чи будь-якого іншого значення:

```ts {7}
import { injectable, inject } from '@ditsmod/core';

import { InterfaceOfItem } from './types';

@injectable()
export class SecondService {
  constructor(@inject('some token for an array') private someArray: InterfaceOfItem[]) {}
  // ...
}
```

Коли використовується `inject`, DI ігнорує тип змінної, натомість використовується переданий в нього альтернативний токен. В даному разі DI ігнорує тип змінної - `InterfaceOfItem[]`, використовуючи в якості токена текстовий токен `some token for an array`.

Майте на увазі, що самий простий та надійний у використанні тип залежності - це клас. DI добре розпізнає типи різних класів, навіть якщо вони мають однакове ім'я, тому декоратор `inject` з ними можна не використовувати. Для усіх інших типів залежностей рекомендуємо використовувати інстанс класу `InjectionToken<T>` у якості токена, в його конструктор передається довільне текстове значення для короткого опису:

```ts {14}
// tokens.ts
import { InjectionToken } from '@ditsmod/core';
import { InterfaceOfItem } from './types';

const SOME_TOKEN = new InjectionToken<InterfaceOfItem[]>('InterfaceOfItem');

// second-service.ts
import { injectable, inject } from '@ditsmod/core';
import { InterfaceOfItem } from './types';
import { SOME_TOKEN } from './tokens';

@injectable()
export class SecondService {
  constructor(@inject(SOME_TOKEN) private someArray: InterfaceOfItem[]) {}
  // ...
}
```

## Провайдер

Вище було сказано, що у DI є реєстр залежностей. Цей реєстр - це мапінг між токеном та значенням, яке потрібно видавати для певної залежності. Умовно це можна показати так:

```
токен1 => значення15
токен2 => значення100
...
```

Такі значення DI створює використовуючи **провайдери**. По-суті, DI вирішує залежність за допомогою відповідних провайдерів, які видають певне значення. Отже, щоб вирішити певну залежність, спочатку необхідно передати відповідний провайдер до реєстру DI, а потім DI буде видавати значення цього провайдера по його токену. Про те, як саме можна передавати провайдери до DI, йдеться [в наступному розділі][100]. Провайдери мають такий тип:

```ts {3-7}
import { Class } from '@ditsmod/core';

type Provider = Class<any> |
{ token: any, useClass: Class<any>, multi?: boolean } |
{ token: any, useValue: any, multi?: boolean } |
{ token?: any, useFactory: [Class<any>, Class<any>.prototype.methodName], multi?: boolean } |
{ token: any, useToken: any, multi?: boolean }
```

_* тут під записом `Class<any>` мається на увазі будь-який клас._

Зверніть увагу, що токен для провайдера з властивістю `useFactory` є опціональним, оскільки DI може використати метод вказаного класу у якості токена.


У прикладі вище, показано визначення типу об'єкта провайдера, у його властивості передаються наступні значення:

- `useClass` - передається клас, DI буде робити інстанс цього класу.
- `useValue` - передається будь-яке значення, DI його видаватиме без змін.
- `useFactory` - передається [tuple][11], де на першому місці повинен бути клас, а на другому місці - метод цього класу, який повинен повернути будь-яке значення для вказаного токена. Наприклад, якщо клас буде таким:

  ```ts
  import { methodFactory } from '@ditsmod/core';

  export class ClassWithFactory {
    @methodFactory()
    method1(dependecy1: Dependecy1, dependecy2: Dependecy2) {
      // ...
      return '...';
    }
  }
  ```

  В такому разі провайдер потрібно передавати до реєстру DI в наступному форматі:

  ```ts
  { token: 'some token', useFactory: [ClassWithFactory, ClassWithFactory.prototype.method1] }
  ```

  Спочатку DI створить інстанс цього класу, потім викличе його метод та отримає результат, який вже і буде асоціюватись з указаним токеном.

- `useToken` - в цю властивість провайдера передається інший токен. Якщо ви записуєте таке:

  ```ts
  { token: SecondService, useToken: FirstService }
  ```

  таким чином ви говорите DI: "Коли споживачі провайдерів запитують токен `SecondService` потрібно використати значення для токена `FirstService`". Іншими словами, ця директива робить аліас `SecondService`, який вказує на `FirstService`. Алгоритм роботи DI в таких випадках наступний:
    - Коли споживачі провайдерів запитують `SecondService`, DI шукатиме для нього значення у своєму реєстрі по токену `FirstService`.
    - Після того, як DI знайде значення для `FirstService`, воно буде повернуто споживачу, що шукав `SecondService`.

Тепер, коли ви вже ознайомились з поняттям **провайдер**, можна уточнити, що під **залежністю** розуміють залежність саме від провайдерів. Таку залежність мають **споживачі** провайдерів або в конструкторах сервісів, або в конструкторах чи методах контролерів, або в методі `get()` [інжекторів][102] (про це буде згадано пізніше).

### Передача провайдерів в реєстр DI

На одну залежність, в реєстр DI потрібно передавати один або декілька провайдерів. Частіше за все, провайдери передаються в реєстр DI через метадані модулів, хоча інколи вони передаються в метадані контролерів, або навіть напряму в [інжектори][102]. В наступному прикладі `SomeService` передається в масив `providersPerMod`:

```ts {7}
import { featureModule } from '@ditsmod/core';

import { SomeService } from './some.service';

@featureModule({
  providersPerMod: [
    SomeService
  ],
})
export class SomeModule {}
```

Після такої передачі, споживачі провайдерів можуть використовувати `SomeService` в межах `SomeModule`. Ідентичний результат буде, якщо ми цей же провайдер передамо у форматі об'єкта:

```ts {7}
import { featureModule } from '@ditsmod/core';

import { SomeService } from './some.service';

@featureModule({
  providersPerMod: [
    { token: SomeService, useClass: SomeService }
  ],
})
export class SomeModule {}
```

І тепер давайте додатково з цим же токеном передамо інший провайдер, але на цей раз у метадані контролера:

```ts {3}
@controller({
  providersPerReq: [
    { token: SomeService, useClass: OtherService }
  ]
})
export class SomeController {
  constructor(private someService: SomeService) {}
  // ...
}
```

Зверніть увагу на виділений рядок. Таким чином ми говоримо DI: "Якщо даний контролер має залежність від провайдера з токеном `SomeService`, її потрібно підмінити інстансом класу `OtherService`". Ця підміна буде діяти тільки для даного контролера. Усі інші контролери в `SomeModule` по токену `SomeService` будуть отримувати інстанси класу `SomeService`.

Аналогічну підміну можна робити на рівні застосунку та на рівні модуля. Це інколи може знадобитись, наприклад коли ви хочете мати дефолтні значення конфігурації на рівні застосунку, але кастомні значення цієї конфігурації на рівні конкретного модуля. В такому разі передамо спочатку дефолтний конфіг в кореневому модулі:

```ts {4}
// ...
@rootModule({
  providersPerApp: [
    ConfigService
  ],
})
export class AppModule {}
```

І вже у певному модулі підмінюємо `ConfigService` на довільне значення:

```ts {4}
// ...
@featureModule({
  providersPerMod: [
    { token: ConfigService, useValue: { propery1: 'some value' } }
  ],
})
export class SomeModule {}
```

## Інжектор

Вище багато разів було сказано за так званий **реєстр DI**. Тепер же, коли ви знаєте для чого DI використовує реєстр, саме час дізнатись, що ці реєстри знаходяться в інжекторах, і таких інжекторів в Ditsmod-застосунку може бути багато. Але спочатку давайте розберемось як працюють інжектори.

Якщо сильно спростити схему роботи DI, можна сказати що DI приймає масив провайдерів на вході, а на виході видає інжектор, який вміє створювати інстанси переданих провайдерів враховуючи залежності між ними. Це має приблизно наступну картину:

```ts {16}
import 'reflect-metadata';
import { Injector, injectable } from '@ditsmod/core';

class Service1 {}

@injectable()
class Service2 {
  constructor(service1: Service1) {}
}

@injectable()
class Service3 {
  constructor(service2: Service2) {}
}

const injector = Injector.resolveAndCreate([Service1, Service2, Service3]);
const service3 = injector.get(Service3);
```

Метод `Injector.resolveAndCreate()` на вході приймає масив класів у свій реєстр, а на виході видає певний об'єкт, що якраз і називається **інжектором**. Цей інжектор очевидно містить у собі реєстр переданих класів, і вміє створювати їхні інстанси, враховуючи весь ланцюжок залежностей (`Service3` -> `Service2` -> `Service1`).

Що робить інжектор:

- коли у нього запитують `Service3`, він проглядає конструктор цього класу, бачить залежність від `Service2`;
- потім проглядає конструктор у `Service2`, бачить залежність від `Service1`;
- потім проглядає конструктор у `Service1`, не знаходить там залежності, і тому першим створює інстанс `Service1`;
- потім створює інстанс `Service2`
- і останнім створює інстанс `Service3`.

Використовуючи DI, вам можна і не знати весь ланцюжок залежностей `Service3`, довірте цю роботу інжектору, головне - передайте в реєстр DI усі необхідні класи. Майте на увазі, що таким чином можна писати unit-тести для окремо взятих класів.

## Ієрархія інжекторів

Ditsmod DI дозволяє створювати ще й ієрархію інжекторів - це коли є батьківські та дочірні інжектори. На перший погляд, немає нічого цікавого у такій ієрархії, бо не зрозуміло для чого вона потрібна, але у Ditsmod ця можливість використовується якраз дуже часто, оскільки вона дозволяє робити архітектуру застосунку модульною. Вивченню специфіки ієрархії варто приділити особливу увагу, це в майбутньому збереже вам не одну годину часу, бо ви знатимете як воно працює і чому воно не знаходить цієї залежності...

При створенні ієрархії, зв'язок утримує лише дочірній інжектор, він має об'єкт батьківського інжектора. В той же час, батьківський інжектор нічого не знає про свої дочірні інжектори. Тобто зв'язок між інжекторами в ієрархії є одностороннім. Умовно, це виглядає наступним чином:

```ts {6}
interface Parent {
  // Тут є певні властивості батьківського інжектора, але немає дочірнього інжектора
}

interface Child {
  parent: Parent;
  // Тут існують інші властивості дочірного інжектора.
}
```

Завдяки наявності об'єкта батьківського інжектора, дочірній інжектор може звертатись до батьківського інжектора, коли у нього запитують інстанс провайдера, якого у нього немає.

Давайте розглянемо наступний приклад. Для спрощення, тут взагалі не використовуються декоратори, оскільки кожен клас є незалежним:

```ts {8-9}
import { Injector } from '@ditsmod/core';

class Service1 {}
class Service2 {}
class Service3 {}
class Service4 {}

const parent = Injector.resolveAndCreate([Service1, Service2]); // Батьківський інжектор
const child = parent.resolveAndCreateChild([Service2, Service3]); // Дочірній інжектор

child.get(Service1); // ОК
parent.get(Service1); // ОК

parent.get(Service1) === child.get(Service1); // true

child.get(Service2); // ОК
parent.get(Service2); // ОК

parent.get(Service2) === child.get(Service2); // false

child.get(Service3); // ОК
parent.get(Service3); // Error - No provider for Service3!

child.get(Service4); // Error - No provider for Service4!
parent.get(Service4); // Error - No provider for Service4!
```

Як бачите, при створенні дочірнього інжектора, йому не передали `Service1`, тому при запиті інстансу цього класу він звернеться до батька. До речі, тут є один неочевидний, але дуже важливий момент: дочірні інжектори тільки запитують у батьківських інжекторів певні інстанси класів, а самостійно вони їх не створюють. Саме тому цей вираз повертає `true`:

```ts
parent.get(Service1) === child.get(Service1); // true
```

А `Service2` є в обох інжекторах, тому кожен із них створить свою локальну версію цього сервіса, і саме через це даний вираз повертає `false`:

```ts
parent.get(Service2) === child.get(Service2); // false
```

Батьківський інжектор не може створити інстансу класу `Service3` через те, що батьківський інжектор не має зв'язку з дочірнім інжектором, в якому є `Service3`.

Ну і обидва інжектори не можуть видати інстансу `Service4`, бо їм не передали цього класу при їхньому створенні.

### Ієрархія інжекторів в застосунку Ditsmod

Раніше в документації ви зустрічали наступні властивості об'єкта, які передаються в метадані модуля або контролера:

- `providersPerApp` - провайдери на рівні застосунку;
- `providersPerMod` - провайдери на рівні модуля;
- `providersPerRou` - провайдери на рівні роута;
- `providersPerReq` - провайдери на рівні HTTP-запиту.

Використовуючи ці масиви, Ditsmod формує з них чотири різні інжектори, що пов'язані між собою ієрархічним зв'язком. Самий вищий в ієрархії - інжектор на рівні застосунку, його реєстр формується з масиву `providersPerApp`. Другий в ієрархії - інжектор на рівні модуля, третій - інжектор на рівні роуту, ну і четвертий - інжектор на рівні HTTP-запиту. Нагадаємо, що вищі в ієрархії інжектори не мають доступу до нижчих в ієрархії інжекторів. Щоб DI успішно вирішив залежності певного провайдера, даний провайдер потрібно передати в найнижчий в ієрархії інжектор серед тих інжекторів, які будуть брати участь у даному вирішенні залежностей.

Наприклад, якщо ви напишете клас, що має залежність від HTTP-запиту, ви зможете його передати тільки у масив `providersPerReq`, бо тільки з цього масиву формується інжектор, до якого Ditsmod буде автоматично додавати провайдер з об'єктом HTTP-запиту. З іншого боку, інстанс цього класу матиме доступ до усіх своїх батьківських інжекторів: на рівні роуту, модуля, та застосунку.

Також ви можете написати певний клас і передати його в масив `providersPerMod`, в такому разі він може залежати тільки від провайдерів на рівні модуля, або на рівні застосунку. Якщо ви спробуєте додати в його конструктор залежності від провайдерів, які ви передали в масив `providersPerRou` чи `providersPerReq`, ви отримаєте помилку про те, що ці провайдери не знайдені. Інстанси провайдерів на рівні модуля створюються єдиний раз після запуску застосунку.

### Ієрархія інжекторів контролера

Будь-який контролер, окрім свого власного інжектора на рівні запиту, має ще й три батьківські інжектори: на рівні роута, модуля та застосунка. Ці інжектори також формуються на основі провайдерів, які ви передаєте в наступні масиви:

- `providersPerApp`;
- `providersPerMod`;
- `providersPerRou`;
- `providersPerReq` (<-- це масив, з якого формується інжектор для контролера).

### Ієрархія інжекторів сервіса

На відміну від контролера, інжектор певного сервіса може бути на будь-якому рівні: на рівні застосунку, модуля, роуту, чи запиту. На практиці це означає, що провайдер для даного сервіса передається в один (або в декілька) із вищезазначених масивів. Наприклад, в наступному прикладі `SomeService` передається в інжектор на рівні запиту, а `OtherService` - на рівні модуля:

```ts
import { featureModule } from '@ditsmod/core';

import { SomeService } from './some.service';
import { OtherService } from './other.service';

@featureModule({
  providersPerMod: [OtherService],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

В даному разі, якщо `SomeService` матиме залежність від `OtherService`, DI зможе створити інстанс `SomeService`, оскільки інжектор на рівні запиту може отримати інстанс `OtherService` від свого батьківського інжектора на рівні модуля. А от якщо навпаки - `OtherService` матиме залежність від `SomeService` - DI не зможе створити інстансу `OtherService`, оскільки інжектор на рівні модуля не бачить свого дочірнього інжектора на рівні запиту.

### Поточний інжектор

Безпосередньо сам інжектор сервіса чи контролера вам рідко може знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { injectable, Injector } from '@ditsmod/core';
import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного сервіса. Рівень ієрархії цього інжектора залежить тільки від того, в реєстр якого інжектора передали `SecondService`.

## Повторне додавання провайдерів

Один і той самий провайдер можна додавати багато разів в метадані модуля чи контролера, але DI вибере той із провайдерів, що додано останнім (виключення з цього правила є, але це стосується лише мульти-провайдерів). Окрім цього, один і той самий провайдер можна передавати одночасно до чотирьох інжекторів на різних рівнях ієрархії, але DI завжди буде вибирати найближчі інжектори (тобто, якщо значення для провайдера запитується на рівні запиту, то спочатку буде проглядатись інжектор на рівні запиту, і лише якщо там немає потрібного провайдера, DI буде підніматись до батьківських інжекторів).

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони передавались на однаковому рівні ієрархії інжекторів.

## Коли DI не може знайти потрібного провайдера

Пам'ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:

1. ви не передали потрібний провайдер до DI в метадані модуля чи контролера (ну або у випадку тестування - у `Injector.resolveAndCreate()`);
2. ви не імпортували модуль, де передається потрібний вам провайдер, або ж цей провайдер не експортується;
3. ви запитуєте у батьківському інжекторі провайдер з дочірнього інжектора.


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://github.com/ts-stack/di
[11]: https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types

[107]: /components-of-ditsmod-app/exports-and-imports
[121]: /components-of-ditsmod-app/providers-collisions
[100]: #передача-провайдерів-в-реєстр-di
[101]: #ієрархія-інжекторів
[102]: #інжектор
