---
sidebar_position: 2
---

# Dependency Injection

Оскільки Ditsmod використовує `@ts-stack/di` у якості бібліотеки для Dependency Injection, необхідно спочатку вивчити її [документацію][9]. Після чого, ви знатимете що означають такі терміни як: інжектор, провайдер, токен, ієрархія інжекторів, підміна провайдерів і т.д.

## Загальне ознайомлення

Якщо дещо спростити схему роботи DI, можна виділити 4 основні етапи:

1. Сканування метаданих, зібраних з декораторів модулів, контролерів та сервісів.
2. На основі просканованих метаданих, формування інжекторів з урахуванням декларацій імпортів/експортів кожного модуля.
3. Запит інстансу певного провайдера.
4. Створення інстансу даного провайдера з використанням раніше сформованих інжекторів.

Перші 2 етапи відбуваються під час ініціалізації застосунку перед стартом веб-сервера.

<!-- :::tip Різниця між провайдером та сервісом
Щоб не плутати поняття **провайдер** із поняттям **сервіс**, можна згадати за провайдерів інтернету.
Таких провайдерів може бути багато, але конкретно вам - сервіс надає один-два провайдери.
Аналогічно в Ditsmod - сервіс ви отримуєте в конкретному контролері, а провайдерів для цього
сервісу може бути багато.
::: -->

## Оголошення рівня провайдерів

Оголошення рівня провайдерів означає, що на цьому рівні інстанси зазначених провайдерів будуть [одинаками][12]. Таке оголошення робиться або у метаданих модуля, або у метаданих контролера.

Наприклад, в контролері можна оголосити провайдери на рівні HTTP-запиту:

```ts
import { Controller } from '@ditsmod/core';

import { SomeService } from './some.service';

@Controller({ providersPerReq: [SomeService] }) // <-------
export class SomeController {
  constructor(private someService: SomeService) {}
}
```

Як бачимо, в метаданих декоратора `Controller` є об'єкт із властивістю `providersPerReq`, куди передається масив провайдерів, яких потребує даний контролер у конструкторі.

В модулі також можна оголошувати провайдери на рівні HTTP-запиту, але вони матимуть нижчій пріоритет, ніж оголошення через контролер:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';

@Module({
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

Під "нижчим пріоритетом" мається на увазі, що якщо інструкції для DI протирічать одна-одній у модулі і у контролері, DI буде використовувати інструкцію контролера.

Наприклад, якщо у модулі буде указано:

```ts
@Module({
  // ...
  providersPerReq: [{ provide: FirstService, useClass: ThirdService }],
})
export class SomeModule {}
```

а у контролері:

```ts
@Controller({ providersPerReq: [{ provide: FirstService, useClass: SecondService }] })
export class SomeController {
  // ..
}
```

То DI використає інструкцію контролера і у конструкторі контролера надасть інстанс класу `SecondService`.

## Повторне додавання провайдерів

У певному модулі, один і той самий провайдер, на одному й тому самому рівні можна додавати багато разів, але DI вибере той із них, що додано останнім (виключення з цього правила є, але це стосується лише [мульти-провайдерів][10]). Окрім цього, один і той самий провайдер можна оголошувати одночасно на чотирьох рівнях, але провайдери в масиві `providersPerReq` матимуть найвищий пріоритет, в масиві `providersPerRou` - нижчій, в масиві `providersPerMod` - ще нижчій, а у `providersPerApp` - найнижчий пріоритет.

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**
2. при потребі змінити дану конфігурацію лише для окремого модуля, оголосіть цей же провайдер конфігурації, але вже **на рівні модуля**, і зробіть його підміну.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони оголошені на однаковому рівні.

## Підміна провайдерів Ditsmod

Оскільки усі default провайдери додаються до DI першими, кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підмінити `Logger` своїм провайдером, ваш провайдер повинен мати такі ж імена методів, і таку ж сигнатуру цих методів як вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну за допомогою DI:

```ts
import { RootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@RootModule({
  providersPerApp: [{ provide: Logger, useClass: MyLogger }],
})
export class SomeModule {}
```

Щоб підмінити будь-який default провайдер Ditsmod вашим власним провайдером, алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте API провайдерів, які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну default провайдера вашим провайдером.

## Області видимості та рівні оголошення

Не варто плутати чотири рівня оголошення провайдерів із областю їх видимості. Коли ви передаєте провайдер у один із масивів: `providersPerApp`, `providersPerMod`, `providersPerRou` чи `providersPerReq` - тим самим ви декларуєте на якому рівні буде створюватись [одинак][12] даного провайдера. Але це не теж саме, що область видимості провайдерів.

Наприклад, якщо у `SomeModule` ви оголосили `ConfigService` на рівні `providersPerMod`, це означає, що одинак даного сервісу буде створений на рівні даного модуля і стане доступним лише в межах цього модуля. Тобто будь-який інший модуль покищо не зможе побачити `ConfigService`.

Разом із тим, щоб збільшити область видимості `ConfigService` ви повинні експортувати його із `SomeModule`, після чого усі модулі, що імпортують `SomeModule`, теж матимуть свій окремий одинак `ConfigService` на рівні модуля.

Як бачите, область видимості провайдерів розширюється за допомогою [експорту цих провайдерів][107] з подальшим імпортом модулів, де вони оголошені. Хоча, якщо провайдери оголошені у кореневому модулі, і вони потрібні вам в іншому модулі, імпортувати кореневий модуль не потрібно. Достатньо в кореневому модулі зробити експорт потрібних провайдерів, після чого їх область видимості збільшиться на увесь застосунок, з урахуванням ієрархії інжекторів.

Але якщо область видимості не розширювати, вона буде обмежуватись лише ієрархією інжекторів DI.

:::tip Коли DI не може знайти потрібного провайдера
Пам'ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:
1. ви не додали потрібний провайдер в метадані модуля чи контролера;
2. ви не імпортували модуль, де є оголошено потрібний вам провайдер, або ж цей провайдер не експортується;
3. ви запитуєте у батьківському інжекторі провайдер із дочірнього інжектора.
:::

## Інжектори DI

Інжектори є складовою частиною DI, саме інжектори видають вам те, що ви запитуєте у конструкторах класів.

Інжектори - це інстанси класів, що мають масиви провайдерів та методи для створення інстансів цих провайдерів, з урахуванням всього ланцюжка їх залежностей. Коли ви передаєте провайдери в масиви `providersPerApp`, `providersPerMod`, `providersPerRou` та `providersPerReq` ви фактично передаєте ці дані в чотири різні інжектори, пов'язані між собою ієрархічним зв'язком. Цей зв'язок утримує дочірній інжектор, оскільки має посилання на батьківський інжектор. У той же час, батьківський інжектор нічого не знає про свої дочірні інжектори.

_Уточнення:_ згадані чотири інжектори - це не загальна кількість інжекторів в застосунку, це кількість інжекторів в ієрархії. Тобто, окремо взятий контролер працює саме із цими чотирма інжекторами, але оскільки контролерів може бути багато, то й інжекторів відповідно може бути більше.

Отже, згадані чотири інжектори мають таку ієрархію:

1. Самий вищий в ієрархії - інжектор на рівні застосунку, він бачить лише ті провайдери, що ви передаєте у масив `providersPerApp` будь-де в застосунку. Він є єдиним на весь застосунок, від нього відгалуджуються дочірні інжектори на рівні модуля.
2. Інжектор на рівні модуля бачить усі провайдери в масиві `providersPerMod` для конкретного модуля, а також в масиві `providersPerApp` будь-де в застосунку. Загальна кількість таких інжекторів дорівнює кількості модулів у застосунку. Від цього інжектора відгалуджуються дочірні інжектори на рівні роуту.
3. Інжектор на рівні роуту бачить усі провайдери в масиві `providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Загальна кількість цих інжекторів дорівнює кількості визначених роутів в контролерах усього застосунку. Від цього інжектора відгалуджуються дочірні інжектори на рівні HTTP-запиту.
4. Інжектор на рівні HTTP-запиту бачить усі провайдери в масиві `providersPerReq`, `providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Загальна кількість цих інжекторів дорівнює кількості одночасних HTTP-запитів, що обробляються у заданий проміжок часу.

Кожен інжектор для створення [одинаків][12] сервісів використовує лише ті провайдери, що оголошені на його рівні. Наприклад, інжектор, на рівні запиту, створює одинаків лише з переліку провайдерів, оголошених в масиві `providersPerReq`. І хоча цей інжектор інколи запитує інстанси провайдерів у батьківських інжекторів, але самостійно він їх не створює. Таким чином, в конструкторі контролера можуть бути одинаки з будь-якого рівня.

Кожен інжектор спочатку проглядає те, що у нього запитують, на своєму рівні. Якщо він це не знаходить, він може звернутись до батьківського інжектора, що знаходиться на рівень вище, якщо такий існує. А батьківський інжектор, у свою чергу, може піднятись ще вище, аж поки не знайде потрібне, в противному разі DI кидає помилку.

Щоб зрозуміти, що це означає на практиці, давайте розглянемо конкретний приклад.

Припустимо ви створили `ErrorHandlerService` і думаєте: "Де б його оголосити? - Раз цей сервіс може знадобитись у будь-якій точці застосунку, значить треба оголосити його саме на рівні застосунку, тобто в масиві `providersPerApp`". Але при цьому, в даному сервісі ви хочете бачити інстанси класу `Req` та `Res`, які в Ditsmod оголошені на рівні запиту:

```ts
import { Injectable } from '@ts-stack/di';
import { Logger, Req, Res, ControllerErrorHandler } from '@ditsmod/core';

@Injectable()
export class ErrorHandlerService implements ControllerErrorHandler {
  constructor(
    private req: Req,
    private res: Res,
    private log: Logger
  ) {}

  handleError(err: Error) {
    // Тут код для обробки помилки
  }
}
```

Ви запускаєте застосунок, і коли справа доходить до роботи цього сервісу, DI кидає помилку, про те, що він не може знайти провайдера для `Req` та `Res`. Але чому? Може їх треба самостійно оголосити на рівні HTTP-запиту, тобто додати їх у масив `providersPerReq`? Ви так і робите, але DI все-одно кидає помилку...

Причина криїться у невірно оголошеному рівні для `ErrorHandlerService`. Оскільки ви оголосили цей сервіс на рівні застосунку, його інстанс буде створювати інжектор на рівні застосунку. А це означає, що усі сервіси, що ви запитуєте в конструкторі, цей інжектор буде шукати тільки в масиві, що ви передали у `providersPerApp`.

Разом з тим, `Req` та `Res` в Ditsmod оголошені на рівні запиту, тобто ці сервіси перебувають у дочірніх інжекторах, по відношенню до інжектора на рівні застосунку. А батьківський інжектор нічого не знає про дочірні інжектори.

Вирішити цю проблему можна двома способами:

1. видаліть `Req` та `Res` з конструктора даного сервіса;
2. оголосіть `ErrorHandlerService` на рівні запиту. Щоправда, в такому разі видимість `ErrorHandlerService` все ще буде обмежуватись тим модулем, де ви оголосили цей провайдер. Як правильно оголосити обробника помилок для контролера, прогляньте [репозиторій ditsmod seed][14].

### Поточний інжектор

Безпосередньо сам інжектор вам рідко може знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { Injectable, Injector } from '@ts-stack/di';
import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного провайдера.


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://ts-stack.github.io/di/
[10]: https://ts-stack.github.io/di/#%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D0%B8

[107]: ./exports-and-imports
[121]: ./providers-collisions
[100]: #підміна-провайдерів-ditsmod