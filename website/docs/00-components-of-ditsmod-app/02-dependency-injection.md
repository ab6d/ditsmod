---
sidebar_position: 2
---

# Dependency Injection

## Базові поняття

Під капотом, Ditsmod використовує [@ts-stack/di][9] у якості бібліотеки для Dependency Injection (скорочено - DI), вона має наступні базові поняття:

- залежність
- токен залежності, типи токенів
- провайдер
- інжектор
- ієрархія інжекторів
- підміна провайдерів

## Залежність

В системі DI, залежність - це усе те, що ви хочете отримати в кінцевому результаті в конструкторах контролерів, сервісів, модулів. Наприклад, якщо в конструкторі сервісу ви прописуєте ось таке:

```ts {7}
import { injectable } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}
  // ...
}
```

це означає, що `SecondService` має залежність від `FirstService`, і очікується що DI вирішить цю залежність наступним чином:

1. спочатку DI прогляне конструктор `FirstService`;
2. потім, якщо у `FirstService` немає залежності, буде створено інстанс `FirstService`;
3. цей інстанс буде передано в конструктор `SecondService`.

Якщо після виконання першого пункту виясниться, що `FirstService` має свої власні залежності, то DI буде виконувати ці три пункти для кожної даної залежності.

### Опціональна залежність

Інколи вам може знадобитись вказати опціональну (необов'язкову) залежність в конструкторі. Давайте розглянемо наступний приклад, де після властивості `firstService` поставлено знак питання, і таким чином вказано для TypeScript що ця властивість є опціональною:

```ts {7}
import { injectable } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private firstService?: FirstService) {}
  // ...
}
```

Але DI проігнорує цю опціональність і видасть помилку у разі відсутності можливості для створення `FirstService`. Щоб даний код працював, необхідно скористатись декоратором `optional`:

```ts {7}
import { injectable, optional } from '@ditsmod/core';

import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(@optional() private firstService?: FirstService) {}
  // ...
}
```

## Токен залежності

У DI є реєстр, що містить мапінг між токеном та значенням для певної залежності. По-суті, токен - це ідентифікатор для певної залежності. В конструкторах модулів, сервісів чи контролерів насправді вказуються не самі залежності, а їхні токени. Для вирішення залежностей, DI буде шукати у своєму реєстрі відповідні значення саме по токенам. 

В розділі [Підміна провайдерів Ditsmod][100] ви дізнаєтесь, що DI дозволяє для одного і того ж токена передавати будь-яке значення в конструктор. Цю особливість зручно використовувати для тестування, оскільки замість справжньої залежності, до конструктора можна передати mock чи stub.

З іншого боку, токен може мати будь-який тип, окрім масиву чи enum. Окрім цього, ви повинні пам'ятати, що токен повинен залишитись у JavaScript-файлі після компіляції з TypeScript-коду, тому у якості токена не можна використовувати інтерфейси або типи, що оголошені за допомогою ключового слова `type`.

Якщо в конструктор вашого класу треба передати масив чи enum, можна скористатись декоратором `inject`:

```ts {7}
import { injectable, inject } from '@ditsmod/core';

import { InterfaceOfItem } from './types';

@injectable()
export class SecondService {
  constructor(@inject('some token for an array') private someArray: InterfaceOfItem[]) {}
  // ...
}
```

Як бачите, `inject` приймає токен для певної залежності. Коли використовується `inject`, DI ігнорує тип змінної, перед якою знаходиться цей декоратор.

## Провайдер

DI вирішує залежність за допомогою відповідних провайдерів, які можуть бути або класами, або об'єктами з таким типом:

```ts {3-6}
import { Type } from '@ditsmod/core';

type Provider = { token: any, useClass: Type<any>, multi?: boolean } |
{ token: any, useValue: any, multi?: boolean } |
{ token: any, useFactory: Function, deps?: any[], multi?: boolean } |
{ token: any, useToken: any, multi?: boolean }
```

На одну залежність, в реєстр DI потрібно передавати один або декілька провайдерів. Частіше за все, така передача відбувається через метадані модуля чи контролера, хоча інколи вони передаються напряму в [інжектори][102].

Тепер, коли ви вже ознайомились з поняттям **провайдер**, можна уточнити, що під **залежністю** розуміють залежність саме від провайдерів. Таку залежність мають **споживачі** провайдерів або в конструкторах класів, або в методі `get()` [інжекторів][102] (про це буде згадано пізніше).

У передньому коді показано визначення типу об'єкта провайдера, у його властивість `provide` передається токен, а в інші властивості передається значення, яке потрібно передавати для даного токена:

- `useClass` - передається клас (DI буде робити інстанс цього класу).
- `useValue` - передається будь-яке значення.
- `useFactory` - передається колбек, який повинен повернути будь-яке значення. Якщо колбек має залежності, токени цих залежностей потрібно передавати в масиві `deps: []`. Наприклад, якщо колбек буде таким:

  ```ts
  function callback(someService: SomeService) {
    // ...
    return 'some value';
  }
  ```

  В такому разі потрібно передавати провайдер в наступному форматі:

  ```ts
  { token: 'some token here', useFactory: callback, deps: [SomeService] }
  ```

- `useToken` - передається інший токен. Якщо ви записуєте таке:

  ```ts
  { token: SecondService, useToken: FirstService }
  ```

  таким чином ви говорите DI: "Коли споживачі провайдерів запитують токен `SecondService` потрібно використати значення, призначене для токена `FirstService`". Іншими словами, ця директива робить аліас `SecondService`, який вказує на `FirstService`. Алгоритм роботи DI в таких випадках наступний:
    - Коли споживачі провайдерів запитують `SecondService`, DI шукатиме для нього значення у своєму реєстрі по токену `FirstService`.
    - Після того, як DI знайде значення для `FirstService`, це значення буде використано 

### Приклади передачі провайдерів в реєстр DI

Частіше за все провайдери передаються в реєстр DI через метадані модулів. В наступному прикладі `SomeService` передається в масив `providersPerMod`:

```ts {7}
import { featureModule } from '@ditsmod/core';

import { SomeService } from './some.service';

@featureModule({
  providersPerMod: [
    SomeService
  ],
})
export class SomeModule {}
```

Після такої передачі, споживачі провайдерів можуть використовувати `SomeService` в межах `SomeModule`. Ідентичний результат буде, якщо ми цей же провайдер передамо у форматі об'єкта:

```ts {7}
import { featureModule } from '@ditsmod/core';

import { SomeService } from './some.service';

@featureModule({
  providersPerMod: [
    { token: SomeService, useClass: SomeService }
  ],
})
export class SomeModule {}
```

І тепер давайте з цим же токеном передамо інший провайдер у метадані контролера:

```ts {3}
@controller({
  providersPerReq: [
    { token: SomeService, useClass: OtherService }
  ]
})
export class SomeController {
  constructor(private someService: SomeService) {}
  // ...
}
```

Зверніть увагу на виділений рядок. Таким чином ми говоримо DI: "Якщо в конструкторі даного контролера є залежність з токеном `SomeService`, її потрібно підмінити інстансом `OtherService`". Ця підміна буде діяти тільки для даного контролера. Усі інші контролери в `SomeModule` по токену `SomeService` будуть отримувати інстанси `SomeService`.

Аналогічну підміну можна робити на рівні застосунку та на рівні модуля. Це інколи може знадобитись, наприклад коли ви хочете мати дефолтні значення конфігурації на рівні застосунку, але кастомні значення цієї конфігурації на рівні конкретного модуля. В такому разі передамо спочатку дефотний конфіг в кореневому модулі:

```ts {4}
// ...
@rootModule({
  providersPerApp: [
    ConfigService
  ],
})
export class AppModule {}
```

І вже у певному модулі підмінюємо `ConfigService` на довільне значення:

```ts {4}
// ...
@featureModule({
  providersPerMod: [
    { token: ConfigService, useValue: { propery1: 'some value' } }
  ],
})
export class SomeModule {}
```

## Інжектор

Якщо сильно спростити схему роботи DI, можна сказати що DI приймає масив провайдерів на вході, а на виході видає інжектор, який вміє створювати інстанси переданих провайдерів враховуючи залежності між ними.

Якщо абстрагуватись від Ditsmod, на практиці це має приблизно наступну картину:

```ts {16}
import 'reflect-metadata';
import { ReflectiveInjector, injectable } from '@ditsmod/core';

class Service1 {}

@injectable()
class Service2 {
  constructor(service1: Service1) {}
}

@injectable()
class Service3 {
  constructor(service2: Service2) {}
}

const injector = ReflectiveInjector.resolveAndCreate([Service1, Service2, Service3]);
const service3 = injector.get(Service3);
```

Метод `ReflectiveInjector.resolveAndCreate()` на вході приймає масив класів, а на виході видає певний об'єкт, що називається **інжектором**. Цей інжектор очевидно містить у собі передані класи, і вміє створювати їхні інстанси, враховуючи весь ланцюжок залежностей (`Service3` -> `Service2` -> `Service1`).

Що робить інжектор:

- коли у нього запитують `Service3`, він проглядає конструктор цього класу, бачить залежність від `Service2`;
- потім проглядає конструктор у `Service2`, бачить залежність від `Service1`;
- потім проглядає конструктор у `Service1`, не знаходить там залежності, і тому першим створює інстанс `Service1`;
- потім створює інстанс `Service2`
- і останнім створює інстанс `Service3`.

В такому разі вам можна і не знати весь ланцюжок залежностей `Service3`, довірте цю роботу інжектору, головне - передайте йому в масив усі необхідні класи. Таким чином можна писати unit-тести для окремо взятих класів.

## Ієрархія інжекторів

Ditsmod DI дозволяє створювати ще й ієрархію інжекторів - це коли є батьківські та дочірні інжектори. На перший погляд, немає нічого цікавого у такій ієрархії, бо не зрозуміло для чого вона потрібна, але у Ditsmod ця можливість використовується якраз дуже часто, оскільки вона дозволяє робити архітектуру застосунку модульною. Вивченню специфіки ієрархії варто приділити особливу увагу, це в майбутньому збереже вам не одну годину часу, бо ви знатимете як воно працює і чому воно не знаходить цієї залежності...

При створенні ієрархії, зв'язок утримує лише дочірній інжектор, він має об'єкт батьківського інжектора. В той же час, батьківський інжектор нічого не знає про свої дочірні інжектори. Тобто зв'язок між інжекторами є одностороннім. Умовно, це виглядає наступним чином:

```ts {6}
interface Parent {
  // Тут є певні властивості батьківського інжектора, але немає дочірнього інжектора
}

interface Child {
  parent: Parent;
  // Тут існують інші властивості дочірного інжектора.
}
```

Завдяки наявності об'єкта батьківського інжектора, дочірній інжектор може звертатись до батьківського інжектора, коли у нього запитують інстанс класу, якого у нього немає.

Давайте розглянемо наступний приклад. Для спрощення, тут взагалі не використовуються декоратори, оскільки кожен клас є незалежним:

```ts {8-9}
import { ReflectiveInjector } from '@ditsmod/core';

class Service1 {}
class Service2 {}
class Service3 {}
class Service4 {}

const parent = ReflectiveInjector.resolveAndCreate([Service1, Service2]); // Батьківський інжектор
const child = parent.resolveAndCreateChild([Service2, Service3]); // Дочірній інжектор

child.get(Service1); // ОК
parent.get(Service1); // ОК

parent.get(Service1) === child.get(Service1); // true

child.get(Service2); // ОК
parent.get(Service2); // ОК

parent.get(Service2) === child.get(Service2); // false

child.get(Service3); // ОК
parent.get(Service3); // Error - No provider for Service3!

child.get(Service4); // Error - No provider for Service4!
parent.get(Service4); // Error - No provider for Service4!
```

Як бачите, при створенні дочірнього інжектора, йому не передали `Service1`, тому при запиті інстансу цього класу він звернеться до батька. До речі, тут є один неочевидний, але дуже важливий момент: дочірні інжектори хоча і запитують у батьківських інжекторів певні інстанси класів, але самостійно вони їх не створюють. Саме тому цей вираз повертає `true`:

```ts
parent.get(Service1) === child.get(Service1); // true
```

А `Service2` є в обох інжекторах, тому кожен із них створить свою локальну версію цього сервіса, і саме через це даний вираз повертає `false`:

```ts
parent.get(Service2) === child.get(Service2); // false
```

Батьківський інжектор не може створити інстансу класу `Service3` через те, що батьківський інжектор не має зв'язку із дочірнім інжектором, в якому є `Service3`.

Ну і обидва інжектори не можуть видати інстансу `Service4`, бо їм не передали цього класу при їхньому створенні.

### Ієрархія інжекторів контролера

Будь-який контролер, окрім свого власного інжектора на рівні запиту, має ще й три батьківські інжектори: на рівні роута, модуля та застосунка. Ці інжектори формуються на основі тих даних, які ви передаєте в наступні масиви:

- `providersPerApp`;
- `providersPerMod`;
- `providersPerRou`;
- `providersPerReq` (<-- це масив, з якого формується інжектор для контролера).

Ці імена властивостей ви можете зустріти або у метаданих контролера, або у метаданих модуля.

### Ієрархія інжекторів сервіса

На відміну від контролера, інжектор певного сервіса може бути на будь-якому рівні: на рівні застосунку, модуля, роуту, чи запиту. На практиці це означає, що провайдер для даного сервіса передається в один (або в декілька) із вищезазначених масивів. Наприклад, в наступному прикладі `SomeService` передається інжектору на рівні запиту, а `OtherService` - на рівні модуля:

```ts
import { featureModule } from '@ditsmod/core';

import { SomeService } from './some.service';
import { OtherService } from './other.service';

@featureModule({
  providersPerMod: [OtherService],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

В даному разі, якщо `SomeService` матиме залежність від `OtherService`, DI зможе створити інстанс `SomeService`, оскільки інжектор на рівні запиту може отримати інстанс `OtherService` від свого батьківського інжектора на рівні модуля. А от якщо навпаки - `OtherService` матиме залежність від `SomeService` - DI не зможе створити інстансу `OtherService`, оскільки інжектор на рівні модуля не бачить свого дочірнього інжектора на рівні запиту.

### Поточний інжектор

Безпосередньо сам інжектор вам рідко може знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { injectable, Injector } from '@ditsmod/core';
import { FirstService } from './first.service';

@injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);  // Lazy loading of dependency
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс даного сервіса.

## Повторне додавання провайдерів

У певному модулі, один і той самий провайдер, можна додавати багато разів в один і той же інжектор, але DI вибере той із провайдерів, що додано останнім (виключення з цього правила є, але це стосується лише [мульти-провайдерів][10]). Окрім цього, один і той самий провайдер можна передавати одночасно до чотирьох інжекторів на різних рівнях, але DI завжди буде вибирати найближчі інжектори (тобто, якщо значення для провайдера запитується на рівні запиту, то спочатку буде проглядатись інжектор на рівні запиту, і лише якщо там немає потрібного провайдера, DI буде підніматись до батьківських інжекторів).

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**;
2. при потребі змінити дану конфігурацію лише для окремого модуля, зробіть підміну цього провайдера, але вже **на рівні модуля**.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є провайдер з таким же токеном, то локальний провайдер матиме вищій пріоритет, при умові, що вони передавались на однаковому рівні.

## Підміна провайдерів

Оскільки усі Ditsmod default провайдери додаються до DI першими, кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підмінити `Logger` своїм провайдером, ваш провайдер повинен мати такі ж імена методів, і таку ж сигнатуру цих методів як вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну за допомогою DI:

```ts {6}
import { rootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@rootModule({
  providersPerApp: [{ token: Logger, useClass: MyLogger }],
})
export class SomeModule {}
```

Щоб підмінити будь-який default провайдер Ditsmod вашим власним провайдером, алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте API провайдерів, які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну default провайдера вашим провайдером.

## Коли DI не може знайти потрібного провайдера

Пам'ятайте, що коли DI не може знайти потрібного провайдера, існує всього три можливі причини:

1. ви не передали потрібний провайдер до DI в метадані модуля чи контролера (ну або у випадку тестування - у `ReflectiveInjector.resolveAndCreate()`);
2. ви не імпортували модуль, де передається потрібний вам провайдер, або ж цей провайдер не експортується;
3. ви запитуєте у батьківському інжекторі провайдер із дочірнього інжектора.


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://ts-stack.github.io/di/
[10]: https://ts-stack.github.io/di/#%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80%D0%B8

[107]: /components-of-ditsmod-app/exports-and-imports
[121]: /components-of-ditsmod-app/providers-collisions
[100]: #підміна-провайдерів
[101]: #ієрархія-інжекторів
[102]: #інжектор
