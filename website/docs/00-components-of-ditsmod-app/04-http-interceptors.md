---
sidebar_position: 4
---

# HTTP Інтерсептори

Інтерсептори дуже близькі по функціональності до контролерів, але вони не створюють роутів, вони прив'язуються до вже існуючих роутів. На одному роуті може працювати ціла група інтерсепторів, що запускаються один за одним. Інтерсептори - це аналог [middleware в ExpressJS][5], але інтерсептори можуть використовувати [DI][6]. Окрім цього, інтерсептори можуть працювати до та після роботи контролера.

Враховуючи що інтерсептори роблять таку ж роботу, яку можуть робити контролери, без інтерсепторів можна обійтись. Але в такому разі вам прийдеться значно частіше викликати різні сервіси в контролерах.

Як правило, інтерсептори використовуються для автоматизації стандартної обробки, такої як:

- парсинг тіла запиту, куків, заголовків;
- валідація запиту;
- збирання та логування різних метрик роботи застосунку.

Інтерсептори можна централізовано підключати або відключати, не змінюючи при цьому код методів контролерів, до яких вони прив'язуються.

## Схема обробки HTTP-запиту

Обробка HTTP-запиту має наступний робочий потік:

1. Ditsmod витягує [PreRouter][7] через [DI][6] (на рівні застосунку).
2. `PreRouter` за допомогою роутера шукає обробника запиту відповідно до URI.
3. Якщо обробника запиту не знайдено, `PreRouter` видає помилку зі статусом 404.
4. Якщо знайшовся обробник запиту, Ditsmod витягує [HttpFrontend][2] через DI, ставить його першим у черзі інтерсепторів і автоматично викликає. By default, цей інтерсептор відповідає за виклик ґардів, встановлення `req.pathParams` та `req.queryParams`, а також за обробку помилок, що виникають під час роботи інтерсепторів та контролера.
5. Другий та наступні інтерсептори можуть і не запуститись, це залежать від того, чи запустить їх попередній у черзі інтерсептор.
6. Якщо усі інтерсептори відпрацювали, Ditsmod запускає [HttpBackend][3], що також витягується через DI. By default, `HttpBackend` запускає безпосередньо метод контролера, що відповідає за обробку поточного запиту.

Отже, приблизний порядок обробки запиту такий:

```text
запит -> PreRouter (створення Promise) -> HttpFrontend -> [інші інтерсептори] -> HttpBackend -> [контролер]
відповідь <- PreRouter (вирішено Promise) <- HttpFrontend <- [інші інтерсептори] <- HttpBackend <- [контролер]
```

Оскільки `PreRouter`, `HttpFrontend` та `HttpBackend` витягуються через DI, ви можете їх підміняти своєю версією відповідних класів. Наприклад, якщо ви хочете не просто відправити 404-ий статус у випадку відсутності потрібного роута, а хочете ще й додати певний текст чи змінити заголовки, ви можете підмінити `PreRouter` своїм класом.

## Створення інтерсептора

Кожен інтерсептор повинен бути класом, що впроваджує інтерфейс [HttpInterceptor][1], та має анотацію з декоратором `injectable`:

```ts
import { injectable } from '@ts-stack/di';
import { HttpHandler, HttpInterceptor } from '@ditsmod/core';

@injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  intercept(next: HttpHandler) {
    return next.handle(); // Here returns Promise<any>;
  }
}
```

Як бачите, метод `intercept()` отримує єдиний аргумент - це інстанс обробника, що викликає наступний інтерсептор. Якщо для своєї роботи інтерсептор потребує певних даних, їх можна отримати в конструкторі через DI, як і в будь-якому сервісі.

Зверніть увагу, що кожен виклик інтерсептора повертає `Promise<any>`, і в кінцевому підсумку він приводить до метода контролера, прив'язаного до відповідного роута. Це означає, що в інтерсепторі ви можете слухати результат резолву проміса, що повертає метод контролера. Щоправда, на даний момент (Ditsmod v2.0.0), `HttpFrontend` та `HttpBackend` by default ігнорують усе, що повертає контролер чи інтерсептори, тому такий резолв проміса може бути корисним для інших цілей - для збору метрик, логування і т.п.

З іншого боку, через DI ви легко можете підмінити `HttpFrontend` та `HttpBackend` своїми власними інтерсепторами, щоб брати до уваги значення, що повертає метод контролера. Один із варіантів такої функціональності реалізовано у модулі [@ditsmod/return][4].

## Передача інтерсептора в інжектор

Будь-який інтерсептор передається в інжектор на рівні запиту за допомогою мульти-провайдерів із токеном `HTTP_INTERCEPTORS`:

```ts
import { HTTP_INTERCEPTORS, Module } from '@ditsmod/core';

import { MyHttpInterceptor } from './my-http-interceptor';

@Module({
  // ...
  providersPerReq: [{ token: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true }],
})
export class SomeModule {}
```

[1]: https://github.com/ditsmod/ditsmod/blob/core-1.0.0/packages/core/src/types/http-interceptor.ts#L9-L11
[2]: https://github.com/ditsmod/ditsmod/blob/core-1.0.0/packages/core/src/types/http-interceptor.ts#L18-L20
[3]: https://github.com/ditsmod/ditsmod/blob/core-1.0.0/packages/core/src/types/http-interceptor.ts#L41-L43
[4]: /published-modules/return
[5]: https://expressjs.com/en/guide/writing-middleware.html
[6]: /components-of-ditsmod-app/dependency-injection
[7]: https://github.com/ditsmod/ditsmod/blob/router-2.3.0/packages/core/src/services/pre-router.ts
