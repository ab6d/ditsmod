---
sidebar_position: 0
---

# Ознайомлення

## Що робить розширення Ditsmod

Сама головна відмінність розширення від звичайного сервісу в тому, що розширення може виконувати свою роботу перед стартом вебсервера, і при цьому воно може динамічно додавати провайдери на рівні конкретного модуля, роуту чи запиту.

Наприклад, в модулі `@ditsmod/body-parser` працює розширення, що динамічно додає HTTP-інтерсептор для парсингу тіла запиту до кожного роута, що має відповідний метод (POST, PATCH, PUT). Воно це робить один раз перед стартом вебсервера, тому за кожним запитом вже немає необхідності тестувати потребу такого парсингу.

Інший приклад. Модуль `@ditsmod/openapi` дозволяє створювати OpenAPI-документацію за допомогою власного декоратора `@OasRoute`. Без роботи розширень, метадані, передані у цей новий декоратор, були б незрозумілими для `@ditsmod/core`.

## Що таке розширення Ditsmod

У Ditsmod **розширенням** називається клас, що впроваджує інтерфейс `Extension`:

```ts
interface Extension<T> {
  init(): Promise<T>;
}
```

Кожне розширення потрібно реєструвати, про це буде згадано пізніше, а зараз припустимо, що така реєстрація відбулася, застосунок запущено, після чого йде наступний процес:

1. збираються метадані з усіх декораторів (`@RootModule`, `@Module`, `@Controller`, `@Route`... і навіть із невідомих декораторів, але при умові, що вони створені за допомогою бібліотеки `@ts-stack/di`);
2. зібрані метадані передаються в DI з токеном `MetadataPerMod1`, отже - будь-яке розширення може отримати ці метадані у себе в конструкторі;
3. починається по-модульна робота розширень, тобто, для кожного модуля Ditsmod відбираються  розширення, створені у цьому модулі, або імпортовані в цей модуль, їм передаються метадані,  зібрані теж у цьому модулі, і викликаються їхні методи `init()`;
4. стартує вебсервер, і застосунок починає працювати у звичному режимі, обробляючи HTTP-запити.

Тут варто врахувати, що порядок запуску розширень можна вважати "випадковим", тому кожне розширення повинно прописувати залежність від іншого розширення (якщо таке є) у своїх конструкторах, а також у методах `init()`. В такому разі, не залежно від порядку запуску, усі розширення працюватимуть коректно:

```ts
async init() {
  await this.otherExtention.init();
  // Робота поточного розширення відбувається після завершення ініціалізації іншого розширення.
}
```

Це означає, що метод `init()` певного розширення може викликатись стільки разів, скільки разів він прописаний у тілі інших розширень, які залежать від роботи даного розширення. Цю особливість необхідно обов'язково враховувати, щоб не відбувалась зайва ініціалізація:

```ts
async init() {
  if (this.inited) {
    return;
  }
  // Щось хороше робите.
  this.inited = true;
}
```
