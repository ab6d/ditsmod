---
sidebar_position: 0
---

# Ознайомлення

## Що робить розширення Ditsmod

Сама головна відмінність розширення від звичайного сервісу в тому, що розширення може виконувати
свою роботу перед стартом вебсервера, і при цьому воно може динамічно додавати провайдери на рівні
конкретного модуля, роута чи запиту.

Наприклад, модуль `@ditsmod/openapi` дозволяє створювати OpenAPI-документацію за допомогою власного
декоратора `@OasRoute`. Без роботи розширень, метадані, передані у цей новий декоратор, були б
незрозумілими для `@ditsmod/core`.

Інший приклад. В модулі `@ditsmod/body-parser` працює розширення, що динамічно додає
HTTP-інтерсептор для парсингу тіла запиту до кожного роута, що має відповідний метод (POST, PATCH,
PUT). Воно це робить один раз перед стартом вебсервера, тому за кожним запитом вже немає
необхідності тестувати потребу такого парсингу.

## Що таке розширення Ditsmod

Ditsmod має спеціальний API для розширення функціональності `@ditsmod/core`. Щоб скористатись
ним, потрібно імпортувати константу `edk` (скорочення від "Extensions Development Kit"):

```ts
import { edk } from '@ditsmod/core';
```

Ця константа використовується як namespace для утримання у ній типів та даних, призначених для
розширень.

У Ditsmod **розширенням** називається клас, що впроваджує інтерфейс `Extension`:

```ts
interface Extension<T> {
  init(): Promise<T>;
}
```

Кожне розширення потрібно реєструвати, про це буде згадано пізніше, а зараз припустимо, що
така реєстрація відбулася, застосунок запущено, після чого йде наступний процес:

1. збираються метадані з усіх декораторів (`@RootModule`, `@Module`, `@Controller`,
   `@Route`...);
2. зібрані метадані передаються в DI з токеном `APP_METADATA_MAP`, отже - будь-який
   сервіс, контролер чи розширення може отримати ці метадані у себе в конструкторі;
3. послідовно запускаються усі зареєстровані розширення, точніше - викликаються їхні
   методи `init()` без аргументів;
4. стартує вебсервер, і застосунок починає працювати у звичному режимі, обробляючи HTTP-запити.

Тут варто врахувати, що порядок запуску розширень можна вважати "випадковим", тому кожне розширення
повинно прописувати залежність від іншого розширення (якщо таке є) у своїх конструкторах, а також у
методах `init()`. В такому разі, не залежно від порядку запуску, усі розширення працюватимуть
коректно:

```ts
async init() {
  await this.otherExtention.init();
  // Робота поточного розширення відбувається після завершення ініціалізації іншого розширення.
}
```

Це означає, що метод `init()` певного розширення може викликатись стільки разів, скільки разів
він прописаний у тілі інших розширень, які залежать від роботи даного розширення. Цю особливість
необхідно обов'язково враховувати, щоб не відбувалась зайва ініціалізація:

```ts
async init() {
  if (this.inited) {
    return;
  }
  // Щось хороше робите.
  this.inited = true;
}
```
