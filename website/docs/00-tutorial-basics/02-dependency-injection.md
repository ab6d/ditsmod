---
sidebar_position: 2
---

# Dependency Injection

На етапі ініціалізації застосунку, DI збирає метадані модулів, контролерів
та сервісів, після чого аналізує **залежність** кожного із класів від інших класів та готує
відповідні набори щоб **вирішити цю залежність**.

Наприклад, якщо модуль безпеки, потребує модуль баз даних та модуль логів, DI готує набір
класів, зібраних із цих двох модулів.

Отже виходить, що якщо певний клас залежить від іншого класу, він його не імпортує напряму з
конкретного файла, а бере через посередника - через систему DI. Така схема роботи дозволяє
підміняти класи через DI.

На практиці це означає, наприклад, що ви можете підміняти by default логер своїм власним логером.
Причому, зверніть увагу, що ви не просто можете використовувати інший логер, а ви можете робити
саме **підміну** вже прописаного в коді логера. Ви можете сказати: "DI, використовуй мій логер у
будь-якому місці застосунку і навіть у ядрі Ditsmod".

Це ж саме стосується будь-яких класів, від яких залежать інші класи - їх усіх можна
підміняти через DI. Тобто окрім логера, ви можете підміняти: роутер, парсер тіла запиту, обробник
помилок, різні by default конфігурації і навіть класи запитів та відповідей.

Для розробника це відкриває широкі можливості як для зміни так і для розширення
застосунку Ditsmod.

І щоб надавати в конструкторі класу те, що ви запитуєте, [DI][8] повинен бути проінструктований
звідки це брати. Але це може здатись дивним. Чому? - Давайте глянемо на приклад:

```ts
import { Injectable } from '@ts-stack/di';

import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}

  methodOne() {
    this.firstService.doSomeThing();
  }
}
```

Тут DI повинен надати інстанс класу `FirstService` і, на перший погляд, ви чітко прописуєте
з якого файлу імпортувати даний клас, але цього не достатньо, бо DI запам'ятовує `FirstService`
лише у якості ключа для пошуку. Це зроблено для того, щоб потім ви могли сказати: "DI, коли бачиш
цей ключ, роби інстанс такого-то класу, і підставляй його сюди".

[Пізніше][100] ви дізнаєтесь, що не змінюючи коду в даному прикладі, ви можете підмінити клас
`FirstService`, наприклад, тестовим класом. Коли ви підмінюєте один клас іншим класом ви, можна
сказати, надаєте інший **провайдер** для створення інстансу класу.

Точно так само, не змінюючи коду прикладу, ви ще можете
змінити **рівень**, на якому оголошено провайдер для `FirstService`, щоб його інстанс
створювався:

- або один єдиний раз при старті застосунку;
- або кожен раз, коли його імпортують в черговий модуль;
- або кожен раз, коли створюється конкретний маршрут;
- або за кожним HTTP-запитом.

Оскільки, не змінюючи коду даного прикладу, ви можете отримувати різні результати у властивості
`firstService`, виходить, що не достатньо просто указати джерело імпорту для певного сервіса.
Для однозначності, як мінімум, необхідно додатково оголосити **рівень** провайдера
`FirstService`.

:::tip Різниця між провайдером та сервісом
Щоб не плутати поняття **провайдер** із поняттям **сервіс**, можна згадати за провайдерів інтернету.
Таких провайдерів може бути багато, але конкретно вам - сервіс надає один-два провайдери.
Аналогічно в Ditsmod - сервіс ви отримуєте в конкретному контролері, а провайдерів для цього
сервісу може бути багато.
:::

### Оголошення рівня провайдерів та підміна провайдерів

Оголошення рівня провайдерів означає, що на цьому рівні інстанси зазначених класів провайдерів
будуть [одинаками][12]. Таке оголошення робиться або у метаданих модуля, або у
метаданих контролера.

Наприклад, в контролері можна оголосити провайдерів на рівні HTTP-запиту:

```ts
import { Controller } from '@ditsmod/core';

import { SomeService } from './some.service';

@Controller({ providersPerReq: [SomeService] })
export class SomeController {
  constructor(private someService: SomeService) {}
}
```

Як бачимо, в метаданих декоратора `Controller` є об'єкт із властивістю
`providersPerReq`, куди передається масив провайдерів, яких потребує даний контролер у
конструкторі.

А якщо ми захочемо зробити підміну провайдера, то ми запишемо це так:

```ts
import { Controller } from '@ditsmod/core';

import { FirstService } from './first.service';
import { SecondService } from './second.service';

@Controller({ providersPerReq: [{ provide: FirstService, useClass: SecondService }] })
export class SomeController {
  constructor(private firstService: FirstService) {}
}
```

Тобто замість передачі класу `FirstService` у масив `providersPerReq`, ми передаємо об'єкт
`{ provide: FirstService, useClass: SecondService }`. Таким чином ми інструктуємо DI щоб для
конструктора замість інстансу класу `FirstService`, передавати інстанс класу `SecondService`.

В модулі також можна оголошувати провайдери на рівні HTTP-запиту, але вони матимуть нижчій
пріоритет, ніж оголошення через контролер:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';

@Module({
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

Як бачите, в метаданих модуля оголошувати провайдери вже можна на **чотирьох рівнях**.

### Пріоритетність провайдерів

Один і той самий провайдер, на одному й тому самому рівні можна додавати багато разів, але
DI вибире той із них, що додано останнім (виключення з цього правила є, але це стосується
лише мульти-провайдерів, про які буде згадано пізніше). Окрім цього, один і той самий провайдер
можна оголошувати одночасно на чотирьох рівнях, але провайдери в масиві `providersPerReq` матимуть
найвищий пріоритет, в масиві `providersPerRou` - нижчій, в масиві `providersPerMod` - ще нижчій,
а у `providersPerApp` - найнижчий пріоритет.

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**
2. при потребі змінити дану конфігурацію лише для окремого модуля, ви оголошуєте цей же провайдер
конфігурації, але вже **на рівні модуля**, і робите його підміну.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі
є такий же провайдер, то локальний провайдер матиме вищій пріоритет, при умові,
що вони оголошені на однаковому рівні. Аналогічне правило діє і для контролера - провайдер,
оголошений у контролері, матиме вищій пріоритет, ніж провайдер, із таким же токеном, оголошений
в модулі.

## Підміна by default провайдерів Ditsmod

У ядрі Ditsmod оголошуються наступні провайдери:

### на рівні застосунку

- Logger
- LoggerConfig
- BodyParserConfig
- Router
- PreRequest
- ExtensionsManager
- PreRouter
- Counter
- ModuleManager

### на рівні HTTP-запиту

- Request
- Response
- BodyParser
- ControllerErrorHandler

Оскільки усі by default провайдери додаються до DI першими,
кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує
усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підміняти `Logger`
своїм провайдером, ваш провайдер повинен мати такі ж методи, і таку ж сигнатуру цих методів як
вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну
за допомогою DI:

```ts
import { RootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@RootModule({
  providersPerApp: [{ provide: Logger, useClass: MyLogger }],
})
export class SomeModule {}
```

Щоб підмінити будь-який by default провайдер Ditsmod вашим власним провайдером,
алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте [API провайдерів][106], які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну by default провайдера вашим провайдером.

### Експорт підмінених by default провайдерів

Хоча сама підміна by default провайдерів для конкретного модуля є простою і зромілою процедурою,
але коли ви експортуватимете ці провайдери для інших модулів, тут ви маєте
схопити приблизно таку помилку:

> Error: Exporting providers in AppModule was failed: Collision was found for:
> BodyParser. You should manually add this provider to AppModule.

Більш докладно про цю помилку можете прочитати у розділі [Колізії провайдерів][121].

## Різниця між областю видимості провайдерів та їх рівнями оголошення

Не варто плутати чотири рівня оголошення провайдерів із областю їх видимості.
Коли ви передаєте провайдер у один із масивів: `providersPerApp`, `providersPerMod`,
`providersPerRou` чи `providersPerReq` - тим самим ви декларуєте на якому рівні буде створюватись
[одинак][12] даного провайдера. Але це не теж саме, що область видимості провайдерів.

Наприклад, якщо у `SomeModule` ви оголосили `ConfigService` на рівні `providersPerMod`, це
означає, що одинак даного сервісу буде створений на рівні даного модуля і стане доступним лише в
межах цього модуля. Тобто будь-який інший модуль покищо не зможе побачити `ConfigService`.

Разом із тим, щоб збільшити область видимості `ConfigService` ви повинні експортувати його із
`SomeModule`, після чого усі модулі, що імпортують `SomeModule`, теж матимуть свій окремий
одинак `ConfigService` на рівні модуля.

Як бачите, область видимості провайдерів розширюється за допомогою [експорту цих провайдерів][107]
з подальшим імпортом модулів, де вони оголошені. Хоча, якщо провайдери оголошені у кореневому
модулі, і вони потрібні вам в іншому модулі, імпортувати кореневий модуль не потрібно. Достатньо
в кореневому модулі зробити експорт потрібних провайдерів, після чого їх область видимості
збільшиться на увесь застосунок.

Але якщо область видимості не розширювати, вона буде обмежуватись лише ієрархією інжекторів DI.

## Інжектори DI

Інжектори є складовою частиною DI, і хоча раніше вони майже не згадувались в документації,
ви з їхньою роботою вже трохи знайомі - саме інжектори видають вам те, що ви запитуєте у
конструкторах класів.

Інжектори - це інстанси класів, що мають масиви провайдерів та методи для
пошуку цих провайдерів. Коли ви передаєте провайдери в масиви `providersPerApp`, `providersPerMod`,
`providersPerRou` та `providersPerReq` ви фактично передаєте ці дані в чотири різні інжектори,
пов'язані між собою ієрархічним зв'язком. Цей зв'язок утримує дочірній інжектор, оскільки має
посилання на батьківський інжектор. У той же час, батьківський інжектор нічого не знає про свої
дочірні інжектори.

_Уточнення_: згадані чотири інжектори - це не загальна кількість інжекторів в застосунку, це
кількість інжекторів в ієрархії. Тобто, окремо взятий контролер працює саме із цими чотирма
інжекторами, але оскільки контролерів може бути багато, то і інжекторів відповідно може бути
більше.

Отже, згадані чотири інжектори мають таку ієрархію:

1. Самий вищий в ієрархії - інжектор на рівні застосунку, він бачить лише ті провайдери,
що ви передаєте у масив `providersPerApp` будь-де в застосунку. Він є єдиним на весь застосунок,
від нього відгалуджуються дочірні інжектори на рівні модуля.
2. Інжектор на рівні модуля бачить усі провайдери в масиві `providersPerMod` для
конкретного модуля, а також в масиві `providersPerApp` будь-де в застосунку. Загальна кількість
таких інжекторів дорівнює кількості модулів у застосунку. Від цього інжектора відгалуджуються
дочірні інжектори на рівні роуту (маршруту).
3. Інжектор на рівні роуту бачить усі провайдери в масиві `providersPerRou` та `providersPerMod`
конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Загальна кількість цих
інжекторів дорівнює кількості визначених роутів в контролерах усього застосунку. Від цього
інжектора відгалуджуються дочірні інжектори на рівні HTTP-запиту.
4. Інжектор на рівні HTTP-запиту бачить усі провайдери в масиві `providersPerReq`,
`providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де
в застосунку. Загальна кількість цих інжекторів дорівнює кількості одночасних HTTP-запитів, що
обробляються у заданий проміжок часу.

Кожен інжектор для створення [одинаків][12] сервісів використовує лише ті провайдери, що оголошені
на його рівні. Наприклад, інжектор, на рівні запиту, створює одинаків лише з переліку провайдерів,
оголошених в масиві `providersPerReq`. І хоча він також бачить провайдерів батьківських
інжекторів, але він може використовувати лише вже готові батьківські інстанси провайдерів, а не
створювати їх. Таким чином, в конструкторі контролера можуть бути одинаки з будь-якого рівня.

Кожен інжектор спочатку проглядає те, що у нього запитують, на своєму рівні. Якщо він це не
знаходить, він може звернутись до батьківського інжектора, що знаходиться на рівень вище, якщо
такий існує. А батьківський інжектор, у свою чергу, може піднятись ще вище, аж поки не знайде
потрібне, в противному разі DI кидає помилку.

Щоб зрозуміти, що це означає на практиці, давайте розглянемо конкретний приклад.

Припустимо ви створили `ErrorHandlerService` і думаєте: "Де б його оголосити? - Раз цей сервіс
може знадобитись у будь-якій точці застосунку, значить треба оголосити його саме на рівні
застосунку, тобто в масиві `providersPerApp`". Але при цьому, в даному сервісі ви хочете бачити
інстанси класу `Request` та `Response`:

```ts
import { Injectable } from '@ts-stack/di';
import { Logger, Request, Response, ControllerErrorHandler } from '@ditsmod/core';

@Injectable()
export class ErrorHandlerService implements ControllerErrorHandler {
  constructor(
    private req: Request,
    private res: Response,
    private log: Logger
  ) {}

  handleError(err: Error) {
    // Тут код для обробки помилки
  }
}
```

Ви запускаєте застосунок, і коли справа доходить до роботи цього сервісу, DI кидає помилку,
про те, що він не може знайти провайдера для `Request` та `Response`. Але чому? Може їх треба
самостійно оголосити на рівні HTTP-запиту, тобто додати їх у масив `providersPerReq`? Ви так і
робите, але DI все-одно кидає помилку...

Причина криїться у невірно оголошеному рівні для `ErrorHandlerService`. Оскільки ви оголосили цей
сервіс на рівні застосунку, ним буде опікуватись інжектор на рівні застосунку. А це означає, що усі
сервіси, що ви запитуєте в конструкторі, цей інжектор буде шукати тільки в масиві, що ви передали у
`providersPerApp`.

Разом з тим, `Request` та `Response` в Ditsmod оголошені на рівні запиту, тобто ці сервіси
перебувають у дочірніх інжекторах, по відношенню до інжектора на рівні застосунку. А батьківський
інжектор нічого не знає про дочірні інжектори.

Вирішити цю проблему можна двома способами:

1. або ви видалите `Request` та `Response` з конструктора даного сервіса;
2. або ви оголосите `ErrorHandlerService` на рівні запиту. Щоправда, в такому разі видимість
`ErrorHandlerService` буде обмежуватись лише тим модулем, де ви оголосили цей провайдер. Як
правильно оголосити обробника помилок для контролера, прогляньте [репозиторій ditsmod/seed][14].

### Поточний інжектор

Швидше за все, безпосередньо сам інжектор вам навряд чи знадобиться, але ви його можете отримати
у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { Injectable, Injector } from '@ts-stack/di';
import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс цього провайдера.

### Токени DI

Інжектори, в якості ключів для пошуку провайдерів, використовують так звані токени. Тип токена може
бути або класом, або об'єктом, або рядком (тобто `string`), або JavaScript-символом
(тобто `symbol`). У якості токена не можуть бути інтерфейси чи типи, що оголошені з
ключовим словом `type`, оскільки після їх компіляції із TypeScript у JavaScript, від них нічого
не залишиться у JavaScript-файлах.

Також, у якості токена не можна використовувати масиви, оскільки покищо у TypeScript не існує
механізму отримання типу цього масиву.

Разом із тим, у конструкторі, в якості токена, найпростіше указати клас певного сервісу:

```ts
import { Injectable } from '@ts-stack/di';

import { SecondService } from './second.service';

@Injectable()
export class FirstService {
  constructor(private secondService: SecondService) {}

  methodOne() {
    this.secondService.doSomeThing();
  }
}
```

DI проглядатиме конструктор, знайде `SecondService`, після чого у відповідних інжекторах шукатиме
провайдера по цьому класу. Тут варто звернути увагу, що DI у якості токена використає саме клас,
а не назву класу.

Для токенів інших типів, в конструкторі необхідно використовувати
декоратор `Inject` перед модифікаторами доступу. Накриклад, у якості токена ви можете
використовувати рядок `tokenForLocal`:

```ts
import { Injectable, Inject } from '@ts-stack/di';

@Injectable()
export class SomeService {
  constructor(@Inject('tokenForLocal') private local: string) {}

  methodOne() {
    this.local;
  }
}
```

В такому разі, щоб DI зміг знайти відповідний провайдер, вам необхідно оголошувати цей провайдер
із таким же токеном:

```ts
import { Module } from '@ditsmod/core';

@Module({
  providersPerMod: [
    { provide: 'tokenForLocal', useValue: 'uk' }
  ]
})
export class SomeModule {}
```

Зверніть увагу, що при оголошенні провайдера, використовується властивість `useValue`. В такому
разі DI не буде намагатись створити інстанс класу, а видасть без змін те значення, що ви
передали.

:::tip Для DI краще використовувати класи
У якості токена для DI рекомендується використовувати саме класи, де тільки це
можливо. Досить рідко може знадобитись використовувати токени інших типів.
:::


### InjectionToken

Окрім можливості використання токенів, що мають різні типи даних, DI має спеціальний клас,
рекомендований для створення токенів - `InjectionToken`. Оскільки він має параметр для типу
(дженерік), ви зможете прочитати тип даних, що буде повертати DI, при запиті конкретного токена:

```ts
import { InjectionToken } from '@ts-stack/di';

export const localToken = new InjectionToken<string>('tokenForLocal');
```

Користуватись ним можна точно так само, як і усіма іншими токенами, що не є класами.
В конструкторі:

```ts
import { Injectable, Inject } from '@ts-stack/di';

import { localToken } from './tokens';

@Injectable()
export class SomeService {
  constructor(@Inject(localToken) private local: string) {}

  methodOne() {
    this.local;
  }
}
```

При оголошенні рівня провайдера:

```ts
import { Module } from '@ditsmod/core';

import { localToken } from './tokens';

@Module({
  providersPerMod: [
    { provide: localToken, useValue: 'uk' }
  ]
})
export class SomeModule {}
```

Зверніть увагу, що `InjectionToken` імпортується з `@ts-stack/di`, а не з `@ditsmod/core`.


[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9

[107]: ./exports-and-imports
[106]: ./api
[121]: ./providers-collisions
[100]: #оголошення-рівня-провайдерів-та-підміна-провайдерів