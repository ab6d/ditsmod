# Розширення функціональності `@ditsmod/core`

Для розширення функціональності `@ditsmod/core` ви можете скористатись відповідним API,
пройшовши три кроки.

## Крок перший

Створіть провайдера, що впроваджує інтерфейс `Extension`:

```ts
import { Injectable } from '@ts-stack/di';

@Injectable()
export class MyExtension implements Extension {
  async init() {
    // ... Do something here
  }
}
```

Метод `init()` не може мати параметрів, оскільки, як мінімум, один раз він буде автоматично
викликатись без аргументів. Для роботи розширення, усі необхідні дані ви
можете отримати або через конструктор, або від іншого розширення через виклик `init()`:

```ts
import { Injectable, Inject } from '@ts-stack/di';
import { edk } from '@ditsmod/core';

@Injectable()
export class Extension1 implements Extension {
  #data: any;

  constructor(@Inject(edk.EXTENSIONS_MAP) private extensionsMap: edk.ExtensionsMap) {}

  async init() {
    if (this.#data) {
      return this.#data;
    }
    // Do something with `this.extensionsMap` here.
    // ...
    this.#data = result;
    return this.#data;
  }
}

@Injectable()
export class Extension2 implements Extension {
  #inited: boolean;

  constructor(private extension1: Extension1) {}

  async init() {
    if (this.#inited) {
      return;
    }

    const data = await this.extension1.init();
    this.#inited = true;
    // Do something here.
  }
}
```

Як бачите, `Extension1` отримує дані для своєї роботи через конструктор. За допомогою токену
`EXTENSIONS_MAP`, ви можете отримати метадані зібрані з вашого застосунку, ці дані призначені
якраз для обробки їх через розширення.

Після того, як `Extension1` виконало свою роботу, воно локально зберігає результат,
і при повторних викликах, віддає його. В `Extension2` теж враховано можливість
повторного виклику `init()`, тому під час другого виклику, цей метод не буде робити повторну
ініціалізацію.

Окрім цього, `Extension2` залежить від даних, взятих з `Extension1`, тому в його конструкторі
указано `Extension1`, а в тілі `init()` асинхронно викликається `this.extension1.init()`.

Хоча `Extension2` залежить від `Extension1`, але Ditsmod автоматично викликає `init()` кожного із
розширень у "непередбаченому" порядку, і при цьому обидва розширення будуть працювати коректно
не залежно від послідовності викликів.

## Крок другий

Зареєструйте розширення в існуючій групі розширень, або створіть нову групу, навіть якщо у ній
буде єдине розширення.

### Реєстрація розширення в існуючій групі розширень

На даний момент, із коробки, Ditsmod має дві групи розширень:
- `ROUTES_EXTENSIONS` - тут реєструються усі розширення, що генерують дані з інтерфейсом
`PreRouteMeta[]` для маршрутизатора;
- `DEFAULT_EXTENSIONS` - тут реєструються усі розширення, що не повертають жодних даних (наприклад,
тут зареєстровано розширення, що встановлює маршрути).

Реєстрація розширень в будь-якій групі відбувається за допомогою мульти-провайдерів:

```ts
import { Module, edk } from '@ditsmod/core';

import { MyExtension } from './my-extension';

@Module({
  // ...
  providersPerApp: [{ provide: edk.DEFAULT_EXTENSIONS, useClass: MyExtension, multi: true }],
  extensions: [edk.DEFAULT_EXTENSIONS],
})
export class SomeModule {}
```

 Ця група
створена щоб розширення указували залежність від  Але ви можете
створювати довільну кількість таких груп.

Для спрощення, у попередньому прикладі вказано залежність `Extension2` від
`Extension1`, але рекомендується указувати залежність саме від групи розширень, а не безпосередньо
від конкретного розширенння. В такому разі, вам не потрібно знати імена усіх розширень, що входять
у групу розширень, достатньо знати лише інтерфейс даних, які повертаються з `init()`.

```ts
import { Module } from '@ditsmod/core';

import { MyExtension } from './my-extension';

@Module({
  // ...
  providersPerApp: [{ provide: ROUTES_EXTENSIONS, useClass: MyExtension, multi: true }],
  extensions: [ROUTES_EXTENSIONS],
})
export class SomeModule {}
```

1. Якщо є декілька розширень, їх можна розбивати по групам за допомогою мульти-провайдерів.
   Наприклад, якщо група розширень відповідає за встановлення маршрутів, їхня реєстрація повинна
   відбуватись за допомогою спеціального токену `ROUTES_EXTENSIONS`:

На даний момент, із коробки Ditsmod має єдину групу розширень - `ROUTES_EXTENSIONS`. Ця група
створена щоб розширення указували залежність від  Але ви можете
створювати довільну кількість таких груп.

Групи розширень можна використовувати щоб встановлювати послідовність отримання даних.
Наприклад, якщо перша група розширень потребує даних від другої групи розширень, то спочатку
збираються дані з першої групи, а потім вже із другої.

Якщо розширення встановлює дані для маршрутів, але не встановлює самих маршрутів, у конструкторі
воно повинно вказати залежність від сервіс-менеджера "по роутам". Кожен елемент роутів повинен
містити дані для встановлення самих роутів, а також дані, що потрібні для обробки цих маршрутів.
