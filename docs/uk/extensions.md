# Розширення функціональності `@ditsmod/core`

Для розширення функціональності `@ditsmod/core` ви можете скористатись відповідним API.
Для цього вам треба пройти два кроки.

## Крок перший

Створіть провайдера, що впроваджує інтерфейс `Extension`:

```ts
import { Injectable } from '@ts-stack/di';

@Injectable()
export class MyExtension implements Extension {
  async init() {
    // ... Do something here
  }
}
```

Метод `init()` не може мати параметрів, оскільки, як мінімум, один раз він буде автоматично
викликатись без аргументів. Усі необхідні дані для роботи розширення ви
можете отримати або через конструктор, або від іншого розширення через виклик `init()`:

```ts
import { Injectable, Inject } from '@ts-stack/di';
import { edk } from '@ditsmod/core';

@Injectable()
export class Extension1 implements Extension {
  #data: any;

  constructor(@Inject(edk.EXTENSIONS_MAP) private extensionsMap: edk.ExtensionsMap) {}

  async init() {
    if (this.#data) {
      return this.#data;
    }
    // Do something with `this.extensionsMap` here.
    // ...
    this.#data = result;
    return this.#data;
  }
}

@Injectable()
export class Extension2 implements Extension {
  #inited: boolean;

  constructor(private extension1: Extension1) {}

  async init() {
    if (this.#inited) {
      return;
    }

    const data = await this.extension1.init();
    // Do something here.
  }
}
```

Як бачите, `Extension1` отримує дані для своєї роботи через конструктор. За допомогою токену
`EXTENSIONS_MAP`, ви можете отримати метадані зібрані з вашого застосунку, ці дані призначені
якраз для обробки їх через розширення.

Після того, як `Extension1` виконало свою роботу, воно локально зберігає результат цієї роботи,
і при повторних викликах, віддає його. В `Extension2` теж враховано можливість
повторного виклику `init()`, тому під час другого виклику, цей метод не буде робити повторну
ініціалізацію.

Окрім цього, `Extension2` залежить від даних, взятих з `Extension1`, тому в його конструкторі
указано `Extension1`, а в тілі `init()` асинхронно викликається `this.extension1.init()`.

Хоча `Extension2` залежить від `Extension1`, але Ditsmod автоматично викликає `init()` кожного із
розширень у "непередбаченому" порядку, і при цьому обидва розширення будуть працювати коректно
не залежно від послідовності викликів.

## Крок другий

Зареєструйте розширення в існуючій групі розширень, або створіть нову групу, навіть якщо у ній
буде єдине розширення. Таку вимогу Ditsmod встановлює, оскільки це дозволить розширенням завжди
ставити в залежність саме групу розширень, а не конкретне розширення.

1. Якщо є декілька розширень, їх можна розбивати по групам за допомогою мульти-провайдерів.
   Наприклад, якщо група розширень відповідає за встановлення маршрутів, їхня реєстрація повинна
   відбуватись за допомогою спеціального токену `ROUTES_EXTENSIONS`:

```ts
import { Module } from '@ditsmod/core';

import { MyExtension } from './my-extension';

@Module({
  // ...
  providersPerApp: [{ provide: ROUTES_EXTENSIONS, useClass: MyExtension, multi: true }],
  extensions: [ROUTES_EXTENSIONS],
})
export class SomeModule {}
```

На даний момент, із коробки Ditsmod має єдину групу розширень - `ROUTES_EXTENSIONS`. Ця група
створена щоб розширення указували залежність від  Але ви можете
створювати довільну кількість таких груп.

Групи розширень можна використовувати щоб встановлювати послідовність отримання даних.
Наприклад, якщо перша група розширень потребує даних від другої групи розширень, то спочатку
збираються дані з першої групи, а потім вже із другої.

Якщо розширення встановлює дані для маршрутів, але не встановлює самих маршрутів, у конструкторі
воно повинно вказати залежність від сервіс-менеджера "по роутам". Кожен елемент роутів повинен
містити дані для встановлення самих роутів, а також дані, що потрібні для обробки цих маршрутів.
